<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Estadística e Inferencia II - 7&nbsp; Procesos Gaussianos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./08_BART.html" rel="next">
<link href="./06_modelos_de_mezcla.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./07_GPs.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Procesos Gaussianos</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Estadística e Inferencia II</a> 
        <div class="sidebar-tools-main tools-wide">
    <div class="dropdown">
      <a href="" title="github" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="github"><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://github.com/LCD-UNSAM/estadistica_e_inferencia_II">
            Fuente
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://github.com/LCD-UNSAM/estadistica_e_inferencia_II/issues/new">
            Reportar errores
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Modo claro/oscuro"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Modo sin distracciones">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">‎</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_Inferencia_Bayesiana.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Inferencia Bayesiana</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_Programación_probabilística.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Programación probabilista</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_Modelos_jerárquicos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Modelado Jerárquico</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_Flujo_de_trabajo_bayesiano.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Flujo de trabajo Bayesiano</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_GLMS.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Modelos lineales y generalizaciones</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_modelos_de_mezcla.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Modelos de mezcla</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_GPs.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Procesos Gaussianos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_BART.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Árboles de regresión aditivos Bayesianos</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#objetivos" id="toc-objetivos" class="nav-link active" data-scroll-target="#objetivos"><span class="header-section-number">7.1</span> Objetivos</a></li>
  <li><a href="#representando-funciones-como-objetos-estocásticos" id="toc-representando-funciones-como-objetos-estocásticos" class="nav-link" data-scroll-target="#representando-funciones-como-objetos-estocásticos"><span class="header-section-number">7.2</span> Representando funciones como objetos estocásticos</a></li>
  <li><a href="#procesos-gaussianos" id="toc-procesos-gaussianos" class="nav-link" data-scroll-target="#procesos-gaussianos"><span class="header-section-number">7.3</span> Procesos Gaussianos</a>
  <ul class="collapse">
  <li><a href="#kernels" id="toc-kernels" class="nav-link" data-scroll-target="#kernels"><span class="header-section-number">7.3.1</span> Kernels</a></li>
  </ul></li>
  <li><a href="#gps-y-regresión" id="toc-gps-y-regresión" class="nav-link" data-scroll-target="#gps-y-regresión"><span class="header-section-number">7.4</span> GPs y regresión</a></li>
  <li><a href="#gps-y-pymc" id="toc-gps-y-pymc" class="nav-link" data-scroll-target="#gps-y-pymc"><span class="header-section-number">7.5</span> GPs y PyMC</a></li>
  <li><a href="#prior-para-la-longitud-de-escala" id="toc-prior-para-la-longitud-de-escala" class="nav-link" data-scroll-target="#prior-para-la-longitud-de-escala"><span class="header-section-number">7.6</span> Prior para la longitud de escala</a></li>
  <li><a href="#gps-generalizados" id="toc-gps-generalizados" class="nav-link" data-scroll-target="#gps-generalizados"><span class="header-section-number">7.7</span> GPs generalizados</a></li>
  <li><a href="#gps-para-clasificación" id="toc-gps-para-clasificación" class="nav-link" data-scroll-target="#gps-para-clasificación"><span class="header-section-number">7.8</span> GPs para clasificación</a></li>
  <li><a href="#cox-processes" id="toc-cox-processes" class="nav-link" data-scroll-target="#cox-processes"><span class="header-section-number">7.9</span> Cox processes</a></li>
  <li><a href="#regresión-con-autocorrelación-espacial" id="toc-regresión-con-autocorrelación-espacial" class="nav-link" data-scroll-target="#regresión-con-autocorrelación-espacial"><span class="header-section-number">7.10</span> Regresión con autocorrelación espacial</a></li>
  <li><a href="#hsgps" id="toc-hsgps" class="nav-link" data-scroll-target="#hsgps"><span class="header-section-number">7.11</span> HSGPs</a></li>
  <li><a href="#resumen" id="toc-resumen" class="nav-link" data-scroll-target="#resumen"><span class="header-section-number">7.12</span> Resumen</a></li>
  <li><a href="#ejercicios" id="toc-ejercicios" class="nav-link" data-scroll-target="#ejercicios"><span class="header-section-number">7.13</span> Ejercicios</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-GPs" class="quarto-section-identifier"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Procesos Gaussianos</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div id="eeadd41e" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> bambi <span class="im">as</span> bmb</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="im">import</span> pytensor.tensor <span class="im">as</span> pt</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="im">import</span> preliz <span class="im">as</span> pz</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="im">from</span> scipy.special <span class="im">import</span> expit <span class="im">as</span> logistic</span>
<span id="cb1-10"><a href="#cb1-10"></a>np.set_printoptions(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb1-11"><a href="#cb1-11"></a>az.style.use(<span class="st">"arviz-doc"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="objetivos" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="objetivos"><span class="header-section-number">7.1</span> Objetivos</h2>
<ul>
<li>Funciones como objetos probabilistas</li>
<li>Kernels</li>
<li>Procesos Gaussianos con likelihoods Gaussianos</li>
<li>Procesos Gaussianos con likelihoods no-gaussianos</li>
<li>Procesos Gaussianos en espacios de Hilbert</li>
</ul>
</section>
<section id="representando-funciones-como-objetos-estocásticos" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="representando-funciones-como-objetos-estocásticos"><span class="header-section-number">7.2</span> Representando funciones como objetos estocásticos</h2>
<p>Comenzaremos nuestro análisis de los procesos gaussianos describiendo primero una forma de representar funciones como objetos probabilísticos. Podemos pensar en una función <span class="math inline">\(f\)</span> como un mapeo desde un conjunto de entradas <span class="math inline">\(X\)</span> a un conjunto de salidas <span class="math inline">\(Y\)</span>:</p>
<p><span class="math display">\[
Y = f(X)
\]</span></p>
<p>Por ejemplo, podríamos tener la función <span class="math inline">\(f(x) = sin(x)\)</span>, donde <span class="math inline">\(X\)</span> es el conjunto de todos los números reales e <span class="math inline">\(Y\)</span> es el conjunto de todos los números reales entre -1 y 1. Si evaluamos la función en una cantidad finita de puntos, podemos representar la función como una tabla de valores.</p>
<div id="b8c3a96e" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>x0 <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi, <span class="dv">10</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a>np.stack([x0, np.sin(x0)]).T</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>array([[ 0.000e+00,  0.000e+00],
       [ 6.981e-01,  6.428e-01],
       [ 1.396e+00,  9.848e-01],
       [ 2.094e+00,  8.660e-01],
       [ 2.793e+00,  3.420e-01],
       [ 3.491e+00, -3.420e-01],
       [ 4.189e+00, -8.660e-01],
       [ 4.887e+00, -9.848e-01],
       [ 5.585e+00, -6.428e-01],
       [ 6.283e+00, -2.449e-16]])</code></pre>
</div>
</div>
<p>De forma similar al graficar una función solo evaluamos la función en unos pocos puntos, pero los sistemas de gráficos como matplotlib y similares interpolan los valores intermedios lo que nos permite obtener una representación de la función que parece “suave”.</p>
<div id="a99c6df5" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>x1 <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi, <span class="dv">100</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>), sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>ax[<span class="dv">0</span>].plot(x0, np.sin(x0), <span class="st">"o--"</span>, color<span class="op">=</span><span class="st">"C0"</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a>ax[<span class="dv">1</span>].plot(x1, np.sin(x1), <span class="st">".-"</span>, color<span class="op">=</span><span class="st">"C0"</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Con estos ejemplos simplemente quiero hacer evidente que muchas veces aproximamos/representamos funciones como una lista ordenada de valores <span class="math inline">\((X_i, Y_i)\)</span>. En principio la lista debería ser infinita, pero por cuestiones prácticas siempre será finita.</p>
<p>Hasta ahora nada nuevo. La novedad es como generalizar esta idea para representar funciones probabilísticamente. Una forma de hacer esto es considerar que cada valor <span class="math inline">\(Y_i\)</span> es una variable aleatoria con una distribución asociada. Por simplicidad, vamos a asumir que la distribución asociada es Gaussiana. Las Gaussianas son conceptualmente fáciles de entender y posen varias propiedades matemáticas que hace simple trabajar con ellas, o al menos más simple que otras alternativas.</p>
<p>El siguiente bloque de código muestra esta idea en práctica con dos variantes:</p>
<ul>
<li><p>La primer “función” la conseguimos asociando una distribución Normal(0, 1) de forma independiente. Es decir, para cada valor de <span class="math inline">\(X_i\)</span> le asociamos un valor <span class="math inline">\(Y_i\)</span> que es una variable aleatoria independiente con distribución Normal(0, 1).</p></li>
<li><p>En el segundo caso el valor de <span class="math inline">\(Y_i\)</span> depende del valor de <span class="math inline">\(Y_{i-1}\)</span>. Es decir, estamos generando una función con más “estructura” en el sentido que los valores de <span class="math inline">\(Y_i\)</span> están correlacionados con los valores de <span class="math inline">\(Y_{i-1}\)</span>.</p></li>
</ul>
<div id="f58da3ea" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>np.random.seed(<span class="dv">237</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">10</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a>y <span class="op">=</span> pz.Normal(<span class="dv">0</span>, <span class="fl">0.2</span>).rvs(<span class="bu">len</span>(x), random_state<span class="op">=</span><span class="dv">237</span>)</span>
<span id="cb5-4"><a href="#cb5-4"></a>plt.plot(x, y, <span class="st">'o-'</span>)</span>
<span id="cb5-5"><a href="#cb5-5"></a>y <span class="op">=</span> np.zeros_like(x)</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x)):</span>
<span id="cb5-8"><a href="#cb5-8"></a>    y[i] <span class="op">=</span> np.random.normal(y[i<span class="op">-</span><span class="dv">1</span>], <span class="fl">0.5</span>)</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a>plt.plot(x, y, <span class="st">'o-'</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>En este punto conviene detenerse y notar que si continuáramos generando “funciones” de esta forma podríamos obtener una aproximación a la función seno, a varias lineas rectas con distinta pendiente, y también a otras funciones. Es decir el procedimiento es lo suficientemente flexible para representar varias funciones, al menos de forma aproximada. Los resultados concretos dependerán de los parámetros que tome cada distribución normal (y también de los valores de <code>x</code>).</p>
<p>De todas formas este procedimiento parece un poco rudimentario como para ser útil en la práctica. Sería útil pensar en algún mecanismo que permita tener mayor control sobre el tipo de funciones que se pueden generar y que permita codificar de forma más simple relaciones entre puntos de la función. Por ejemplo es común que las funciones varíen de forma suave, es decir esperamos que para dos valores similares de <span class="math inline">\(X_i\)</span> obtengamos valores similares de <span class="math inline">\(Y_i\)</span>.</p>
<p>Una vía razonable para alcanzar este objetivo es reemplazar el uso de <span class="math inline">\(n\)</span> gaussianas univariadas por una sola Gaussiana multivariada de dimensión <span class="math inline">\(n\)</span>. Una Gaussiana multivariada se define por una vector media y una matriz de covarianza. La matriz de covarianza representa la relación entre las diferentes variables aleatorias. Por ejemplo, si la matriz de covarianza es diagonal, entonces las variables aleatorias son independientes.</p>
<div id="83c7af6d" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="cf">for</span> cov, ax <span class="kw">in</span> <span class="bu">zip</span>([[[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>]], </span>
<span id="cb6-4"><a href="#cb6-4"></a>                    [[<span class="dv">1</span>, <span class="fl">0.5</span>], [<span class="fl">0.5</span>, <span class="dv">1</span>]], </span>
<span id="cb6-5"><a href="#cb6-5"></a>                    [[<span class="dv">1</span>, <span class="fl">0.99</span>], [<span class="fl">0.99</span>, <span class="dv">1</span>]], </span>
<span id="cb6-6"><a href="#cb6-6"></a>                    [[<span class="dv">2</span>, <span class="op">-</span><span class="fl">0.5</span>], [<span class="op">-</span><span class="fl">0.5</span>, <span class="dv">2</span>]]], axes.ravel()):</span>
<span id="cb6-7"><a href="#cb6-7"></a>    pz.MvNormal([<span class="dv">0</span>, <span class="dv">0</span>], cov).plot_pdf(marginals<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>ax)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>En el caso de las funciones, la matriz de covarianza codifica la relación entre los valores de la función evaluada en diferentes puntos. Como se muestra en la siguiente figura para una gaussiana bivariada. Desde esta perspectiva muestrear puntos de la Gaussiana multivariada es equivalente a muestrear una función. Podemos ver que la dimensionalidad de la Gaussiana multivariada es igual a la cantidad de puntos que queremos usar para muestrear de la función (o punto a representar).</p>
<div id="33e7dbe5" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>_, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>,<span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>), sharex<span class="op">=</span><span class="st">"col"</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a>dist <span class="op">=</span> pz.MvNormal([<span class="dv">0</span>, <span class="dv">0</span>], [[<span class="dv">1</span>, <span class="fl">0.5</span>], [<span class="fl">0.5</span>, <span class="dv">1</span>]])</span>
<span id="cb7-3"><a href="#cb7-3"></a>vals <span class="op">=</span> dist.rvs(<span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">239</span>)</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="cf">for</span> idx, v <span class="kw">in</span> <span class="bu">enumerate</span>(vals):</span>
<span id="cb7-5"><a href="#cb7-5"></a>    dist.plot_pdf(marginals<span class="op">=</span><span class="va">False</span>, ax<span class="op">=</span>axes[idx,<span class="dv">0</span>])</span>
<span id="cb7-6"><a href="#cb7-6"></a>    axes[idx,<span class="dv">0</span>].set_title(<span class="st">""</span>)</span>
<span id="cb7-7"><a href="#cb7-7"></a>    axes[idx,<span class="dv">0</span>].plot(<span class="op">*</span>v, <span class="st">"k."</span>)</span>
<span id="cb7-8"><a href="#cb7-8"></a>    axes[idx, <span class="dv">1</span>].plot([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>], v, <span class="st">"ko--"</span>)</span>
<span id="cb7-9"><a href="#cb7-9"></a>    axes[idx, <span class="dv">1</span>].set_xticks([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>], [<span class="st">"X_0"</span>, <span class="st">"X_1"</span>])</span>
<span id="cb7-10"><a href="#cb7-10"></a>    axes[idx, <span class="dv">1</span>].set_xlim(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb7-11"><a href="#cb7-11"></a>    axes[idx, <span class="dv">1</span>].set_yticks([])</span>
<span id="cb7-12"><a href="#cb7-12"></a>    axes[idx, <span class="dv">0</span>].set_xticks([])</span>
<span id="cb7-13"><a href="#cb7-13"></a>    axes[idx, <span class="dv">0</span>].set_xlabel(<span class="st">"X_0"</span>)</span>
<span id="cb7-14"><a href="#cb7-14"></a>    axes[idx, <span class="dv">0</span>].set_ylabel(<span class="st">"X_1"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-7-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="procesos-gaussianos" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="procesos-gaussianos"><span class="header-section-number">7.3</span> Procesos Gaussianos</h2>
<p>Hasta ahora hemos venido hablando de funciones como objetos probabilísticos desde una perspectiva que parece un poco artificial, casi como un truco. Hicimos este recorrido, a fin de generar intuición. Sin embargo, es posible formalizar de forma rigurosa la representación de funciones como objetos probabilísticos. Para ello necesitamos introducir el concepto de proceso estocástico.</p>
<blockquote class="blockquote">
<p>Un proceso estocástico es una colección de variables aleatorias indexadas por un conjunto de índices. Asi como una muestra de una distribución unidimensional es un número, una muestra (o realización) de un proceso estocástico es una función. Por ello a los procesos estocásticos se los suele llamar función aleatoria.</p>
</blockquote>
<p>Es común que los índices representen tiempo, pero esto no es necesario. En los ejemplos anteriores los indices vienen dados por lo valores de <span class="math inline">\(X_i\)</span> y las variables aleatorias son los valores de <span class="math inline">\(Y_i\)</span>. Estos indices funcionan de forma similar a los indices en “listas” o “vectores” en programación, con la diferencia que en este caso los indices son reales y no enteros.</p>
<p>Existen muchos tipos de procesos estocásticos, uno de ellos se llama Proceso Gaussiano (GP).</p>
<blockquote class="blockquote">
<p>Un proceso gaussiano es un proceso estocástico tal que cualquier subconjunto finito de variables aleatorias tiene una distribución Gaussiana.</p>
</blockquote>
<p>En otras palabras, un proceso gaussiano es <em>como</em> una Gaussiana multivariada de dimensión infinita, pero que si la evaluamos en cualquier conjunto finito de valores obtenemos una Gaussiana multivariada de dimensión finita. Esta propiedad es sumamente útil, por que matemáticamente y conceptualmente estamos trabajando con un objeto infinito (como lo es la función seno, por ej), pero si marginalizamos sobre todos los puntos NO observados obtenemos una Gaussiana multivariada definida por los puntos observados!</p>
<p>El principal interés de los GPs en estadística Bayesiana, es que podemos pensarlos con una distribución sobre funciones.</p>
<p>Un GP, se define estrictamente por un vector media infinito y una matriz de covarianza infinita, pero como ya mencionamos, en la práctica siempre trabajamos en un espacio finito. Por lo que vector media y la matriz de covarianza son finitos. En la práctica es común trabajar con un vector media cero, por lo que el GP queda definido de forma completa por la matriz de covarianza.</p>
<section id="kernels" class="level3" data-number="7.3.1">
<h3 data-number="7.3.1" class="anchored" data-anchor-id="kernels"><span class="header-section-number">7.3.1</span> Kernels</h3>
<p>En la práctica, las matrices de covarianza se especifican mediante funciones conocidas como kernels. Lamentablemente, el término kernel es muy polisémico, incluso en la literatura estadística. Cuando estemos hablando de GPs llamaremos kernel a cualquier función que devuelva una matriz de covarianza válida.</p>
<p>Hay muchos kernels útiles, uno popular es el kernel cuadrático exponencial:</p>
<p><span class="math display">\[
\kappa(\mathbf{X}, \mathbf{X'}) = \exp\left(-\frac{\|\mathbf{X} - \mathbf{X'}\|^2}{2\ell^2}\right)
\]</span></p>
<p>Aquí, <span class="math inline">\(\|\mathbf{X} - \mathbf{X'}\|^2\)</span> es la distancia euclidea al cuadrado:</p>
<p><span class="math display">\[
\|\mathbf{X} - \mathbf{X'}\|^2 = (X_1 - X'_1)^2 + (X_2 - X'_2)^2 + \dots + (X_n -X'_n)^2
\]</span></p>
<p>Para este kernel, podemos ver que tenemos una función simétrica que toma dos entradas y devuelve un valor de 0 si las entradas son iguales, o positivo en caso contrario. Y así podemos interpretar la salida del kernel cuadrático exponenciado como una medida de similitud entre las dos entradas.</p>
<p>Puede que no sea obvio a primera vista, pero el kernel cuadrático exponencial tiene una fórmula similar a la distribución Gaussiana. Por esta razón, este kernel también se llama kernel Gaussiano. El término <span class="math inline">\(\ell\)</span> se conoce como la longitud de escala (o ancho de banda o varianza) y controla el “ancho” del kernel. En otras palabras, controla a qué escala los valores <span class="math inline">\(X\)</span> se consideran similares.</p>
<p>Para comprender mejor el papel de los kernels juguemos un poco. En el siguiente bloque de código definimos un kernel cuadrático exponencial y luego lo evaluamos en 3 puntos <code>A</code>, <code>B</code> y <code>C</code>, que toman los valores <code>-1, 0.7, 1.5</code>.</p>
<div id="9144eef6" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">def</span> exp_quad_kernel(x, xi, ℓ<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="co">"""kernel cuadrático exponencial"""</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="cf">return</span> np.array([np.exp(<span class="op">-</span>(x<span class="op">-</span>x_i)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>ℓ<span class="op">**</span><span class="dv">2</span>)) <span class="cf">for</span> x_i <span class="kw">in</span> xi])</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a>labels <span class="op">=</span> [<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>]</span>
<span id="cb8-7"><a href="#cb8-7"></a>datos <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>, <span class="fl">0.7</span>, <span class="fl">1.5</span>])</span>
<span id="cb8-8"><a href="#cb8-8"></a>cov <span class="op">=</span> exp_quad_kernel(datos, datos, <span class="dv">1</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La siguiente figura muestra, a la izquierda, los tres puntos y a la derecha la matriz de covarianza generada a partir del kernel. Podemos ver que mientras más similares los datos, más cercana a 1 la correspondiente entrada en la matriz, y mientras más dicímiles más cercana a 0. Cuanto es “similar” es controlado por el parámetro <span class="math inline">\(\ell\)</span>.</p>
<div id="cell-fig-ExpQuad" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb9-2"><a href="#cb9-2"></a>ax <span class="op">=</span> np.ravel(ax)</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a>ax[<span class="dv">0</span>].plot(datos, np.zeros_like(datos), <span class="st">'ko'</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a>ax[<span class="dv">0</span>].set_yticks([])</span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="cf">for</span> i, l <span class="kw">in</span> <span class="bu">zip</span>(datos, labels):</span>
<span id="cb9-7"><a href="#cb9-7"></a>    ax[<span class="dv">0</span>].text(i, <span class="dv">0</span><span class="op">+</span><span class="fl">0.005</span>, l)</span>
<span id="cb9-8"><a href="#cb9-8"></a>ax[<span class="dv">0</span>].set_xticks(datos)</span>
<span id="cb9-9"><a href="#cb9-9"></a>ax[<span class="dv">0</span>].set_xticklabels(np.<span class="bu">round</span>(datos, <span class="dv">2</span>))</span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a>ax[<span class="dv">1</span>].grid(<span class="va">False</span>)</span>
<span id="cb9-12"><a href="#cb9-12"></a>im <span class="op">=</span> ax[<span class="dv">1</span>].imshow(cov, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-13"><a href="#cb9-13"></a>colors <span class="op">=</span> [<span class="st">'w'</span>, <span class="st">'k'</span>]</span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(cov)):</span>
<span id="cb9-15"><a href="#cb9-15"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(cov)):</span>
<span id="cb9-16"><a href="#cb9-16"></a>        ax[<span class="dv">1</span>].text(j, i, <span class="bu">round</span>(cov[i, j], <span class="dv">2</span>),</span>
<span id="cb9-17"><a href="#cb9-17"></a>                   color<span class="op">=</span>colors[<span class="bu">int</span>(im.norm(cov[i, j]) <span class="op">&gt;</span> <span class="fl">0.5</span>)],</span>
<span id="cb9-18"><a href="#cb9-18"></a>                   ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>, fontdict<span class="op">=</span>{<span class="st">'size'</span>: <span class="dv">16</span>})</span>
<span id="cb9-19"><a href="#cb9-19"></a>ax[<span class="dv">1</span>].set_xticks(<span class="bu">range</span>(<span class="bu">len</span>(datos)), labels)</span>
<span id="cb9-20"><a href="#cb9-20"></a>ax[<span class="dv">1</span>].set_yticks(<span class="bu">range</span>(<span class="bu">len</span>(datos)), labels)</span>
<span id="cb9-21"><a href="#cb9-21"></a>ax[<span class="dv">1</span>].xaxis.tick_top()</span>
<span id="cb9-22"><a href="#cb9-22"></a>fig.colorbar(im, ax<span class="op">=</span>ax[<span class="dv">1</span>])<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-expquad" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-expquad-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07_GPs_files/figure-html/fig-expquad-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-expquad-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;7.1: Relación entre valores de entrada de un kernel cuadrático exponencial y la matriz de covarianza inducida
</figcaption>
</figure>
</div>
</div>
</div>
<p>La siguiente figura muestra algunos kernels y las matrices resultantes.</p>
<div id="28df56e0" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>X <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">200</span>)[:,<span class="va">None</span>]</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-4"><a href="#cb10-4"></a>covs <span class="op">=</span> [pm.gp.cov.ExpQuad(input_dim<span class="op">=</span><span class="dv">1</span>, ls<span class="op">=</span><span class="dv">1</span>), </span>
<span id="cb10-5"><a href="#cb10-5"></a>        pm.gp.cov.Matern32(input_dim<span class="op">=</span><span class="dv">1</span>, ls<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb10-6"><a href="#cb10-6"></a>        pm.gp.cov.Linear(input_dim<span class="op">=</span><span class="dv">1</span>, c<span class="op">=</span><span class="dv">50</span>),</span>
<span id="cb10-7"><a href="#cb10-7"></a>        pm.gp.cov.Cosine(input_dim<span class="op">=</span><span class="dv">1</span>, ls<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb10-8"><a href="#cb10-8"></a>        pm.gp.cov.Polynomial(input_dim<span class="op">=</span><span class="dv">1</span>, c<span class="op">=</span><span class="dv">70</span>, d<span class="op">=</span><span class="dv">3</span>, offset<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb10-9"><a href="#cb10-9"></a>        pm.gp.cov.Constant(c<span class="op">=</span><span class="dv">50</span>),</span>
<span id="cb10-10"><a href="#cb10-10"></a>       ]</span>
<span id="cb10-11"><a href="#cb10-11"></a>        </span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="cf">for</span> cov, ax <span class="kw">in</span> <span class="bu">zip</span>(covs, ax.ravel()):</span>
<span id="cb10-13"><a href="#cb10-13"></a>    m <span class="op">=</span> ax.imshow(cov(X).<span class="bu">eval</span>())</span>
<span id="cb10-14"><a href="#cb10-14"></a>    ax.set_title(cov.__class__.<span class="va">__name__</span>)</span>
<span id="cb10-15"><a href="#cb10-15"></a>ax.set_xticks([])</span>
<span id="cb10-16"><a href="#cb10-16"></a>ax.set_yticks([])<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>A continuación vamos a usar algo que quizá es más intuitivo que analizar matrices de covarianzas. Vamos a muestrar GPs, para distinos kernels con distintos parámetros.</p>
<div id="cell-fig-ExpQuad_ell" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>np.random.seed(<span class="dv">24</span>)</span>
<span id="cb11-2"><a href="#cb11-2"></a>test_points <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>)[:,<span class="va">None</span>]</span>
<span id="cb11-3"><a href="#cb11-3"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">5</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-4"><a href="#cb11-4"></a>ax <span class="op">=</span> np.ravel(ax)</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="cf">for</span> idx, ℓ <span class="kw">in</span> <span class="bu">enumerate</span>((<span class="fl">0.2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">10</span>)):</span>
<span id="cb11-7"><a href="#cb11-7"></a>    cov <span class="op">=</span> pm.gp.cov.ExpQuad(input_dim<span class="op">=</span><span class="dv">1</span>, ls<span class="op">=</span>ℓ)</span>
<span id="cb11-8"><a href="#cb11-8"></a>    ax[idx].plot(test_points, pz.MvNormal(mu<span class="op">=</span>np.zeros_like(test_points)[:,<span class="dv">0</span>],</span>
<span id="cb11-9"><a href="#cb11-9"></a>                                          cov<span class="op">=</span>cov(test_points).<span class="bu">eval</span>()).rvs(<span class="dv">2</span>).T)</span>
<span id="cb11-10"><a href="#cb11-10"></a>    ax[idx].set_title(<span class="ss">f'ℓ =</span><span class="sc">{ℓ}</span><span class="ss">'</span>)</span>
<span id="cb11-11"><a href="#cb11-11"></a>fig.text(<span class="fl">0.48</span>, <span class="dv">1</span>, <span class="st">'ExpQuad'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb11-12"><a href="#cb11-12"></a>fig.text(<span class="fl">0.51</span>, <span class="op">-</span><span class="fl">0.05</span>, <span class="st">'x'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb11-13"><a href="#cb11-13"></a>fig.text(<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">0.5</span>, <span class="st">'f(x)'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-expquad_ell" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-expquad_ell-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07_GPs_files/figure-html/fig-expquad_ell-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-expquad_ell-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;7.2: Realizaciones del Kernel ExpQuad para distintos valores de la longitud de escala
</figcaption>
</figure>
</div>
</div>
</div>
<div id="dc49c587" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>np.random.seed(<span class="dv">24</span>)</span>
<span id="cb12-2"><a href="#cb12-2"></a>test_points <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>)[:,<span class="va">None</span>]</span>
<span id="cb12-3"><a href="#cb12-3"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">5</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-4"><a href="#cb12-4"></a>ax <span class="op">=</span> np.ravel(ax)</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="cf">for</span> idx, ℓ <span class="kw">in</span> <span class="bu">enumerate</span>((<span class="fl">0.2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">10</span>)):</span>
<span id="cb12-7"><a href="#cb12-7"></a>    cov <span class="op">=</span> pm.gp.cov.Matern32(input_dim<span class="op">=</span><span class="dv">1</span>, ls<span class="op">=</span>ℓ)</span>
<span id="cb12-8"><a href="#cb12-8"></a>    ax[idx].plot(test_points, pz.MvNormal(mu<span class="op">=</span>np.zeros_like(test_points)[:,<span class="dv">0</span>],</span>
<span id="cb12-9"><a href="#cb12-9"></a>                                          cov<span class="op">=</span>cov(test_points).<span class="bu">eval</span>()).rvs(<span class="dv">4</span>).T)</span>
<span id="cb12-10"><a href="#cb12-10"></a>    ax[idx].set_title(<span class="ss">f'ℓ=</span><span class="sc">{ℓ}</span><span class="ss">'</span>)</span>
<span id="cb12-11"><a href="#cb12-11"></a>fig.text(<span class="fl">0.48</span>, <span class="dv">1</span>, <span class="st">'Matern32'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb12-12"><a href="#cb12-12"></a>fig.text(<span class="fl">0.51</span>, <span class="op">-</span><span class="fl">0.05</span>, <span class="st">'x'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb12-13"><a href="#cb12-13"></a>fig.text(<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">0.5</span>, <span class="st">'f(x)'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="7f03163f" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>np.random.seed(<span class="dv">24</span>)</span>
<span id="cb13-2"><a href="#cb13-2"></a>test_points <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>)[:,<span class="va">None</span>]</span>
<span id="cb13-3"><a href="#cb13-3"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">5</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-4"><a href="#cb13-4"></a>ax <span class="op">=</span> np.ravel(ax)</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="cf">for</span> idx, c <span class="kw">in</span> <span class="bu">enumerate</span>((<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">9</span>)):</span>
<span id="cb13-7"><a href="#cb13-7"></a>    cov <span class="op">=</span> pm.gp.cov.Linear(input_dim<span class="op">=</span><span class="dv">1</span>, c<span class="op">=</span>c)</span>
<span id="cb13-8"><a href="#cb13-8"></a>    ax[idx].plot(test_points, pz.MvNormal(mu<span class="op">=</span>np.zeros_like(test_points)[:,<span class="dv">0</span>],</span>
<span id="cb13-9"><a href="#cb13-9"></a>                                          cov<span class="op">=</span>cov(test_points).<span class="bu">eval</span>()).rvs(<span class="dv">4</span>).T)</span>
<span id="cb13-10"><a href="#cb13-10"></a>    ax[idx].set_title(<span class="ss">f'c =</span><span class="sc">{</span>c<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb13-11"><a href="#cb13-11"></a>fig.text(<span class="fl">0.48</span>, <span class="dv">1</span>, <span class="st">'Linear'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb13-12"><a href="#cb13-12"></a>fig.text(<span class="fl">0.51</span>, <span class="op">-</span><span class="fl">0.05</span>, <span class="st">'x'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb13-13"><a href="#cb13-13"></a>fig.text(<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">0.5</span>, <span class="st">'f(x)'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="97b60475" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>np.random.seed(<span class="dv">24</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a>test_points <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">200</span>)[:,<span class="va">None</span>]</span>
<span id="cb14-3"><a href="#cb14-3"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">5</span>), sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-4"><a href="#cb14-4"></a>ax <span class="op">=</span> np.ravel(ax)</span>
<span id="cb14-5"><a href="#cb14-5"></a></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="cf">for</span> idx, ℓ <span class="kw">in</span> <span class="bu">enumerate</span>((<span class="fl">0.2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">10</span>)):</span>
<span id="cb14-7"><a href="#cb14-7"></a>    cov <span class="op">=</span> pm.gp.cov.Cosine(input_dim<span class="op">=</span><span class="dv">1</span>, ls<span class="op">=</span>ℓ)</span>
<span id="cb14-8"><a href="#cb14-8"></a>    ax[idx].plot(test_points, pz.MvNormal(mu<span class="op">=</span>np.zeros_like(test_points)[:,<span class="dv">0</span>],</span>
<span id="cb14-9"><a href="#cb14-9"></a>                                          cov<span class="op">=</span>cov(test_points).<span class="bu">eval</span>()).rvs(<span class="dv">2</span>).T)</span>
<span id="cb14-10"><a href="#cb14-10"></a>    ax[idx].set_title(<span class="ss">f'c =</span><span class="sc">{ℓ}</span><span class="ss">'</span>)</span>
<span id="cb14-11"><a href="#cb14-11"></a>fig.text(<span class="fl">0.48</span>, <span class="dv">1</span>, <span class="st">'Cosine'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb14-12"><a href="#cb14-12"></a>fig.text(<span class="fl">0.51</span>, <span class="op">-</span><span class="fl">0.05</span>, <span class="st">'x'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb14-13"><a href="#cb14-13"></a>fig.text(<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">0.5</span>, <span class="st">'f(x)'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-14-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="gps-y-regresión" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="gps-y-regresión"><span class="header-section-number">7.4</span> GPs y regresión</h2>
<p>Los procesos gaussianos son distribuciones a priori sobre funciones, es decir podemos escribir</p>
<p><span class="math display">\[
f(x) \sim \mathcal{GP}(\mathbf{\mu}, \mathbf{\Sigma})
\]</span></p>
<p>Donde <span class="math inline">\(\mathcal{GP}\)</span> representa un proceso Gaussiano con función media <span class="math inline">\(\mathbf{\mu}\)</span> y función de covarianza <span class="math inline">\(\mathbf{\Sigma}\)</span>.</p>
<p>Si la distribución a priori es un GP y el likelihood es una Gaussiana con varianza <span class="math inline">\(\sigma^2\)</span>, entonces la distribución a posteriori es también un GP de la siguiente forma:</p>
<p><span class="math display">\[
p(Y \mid \psi, \sigma) \sim \mathcal{N}(\mathbf{\mu}_{\text{post}}, \mathbf{\Sigma}_{\text{post}})
\]</span></p>
<p>Donde <span class="math inline">\(k\)</span> es un kernel con (hiper)parámetros <span class="math inline">\(\psi\)</span> y</p>
<p><span class="math display">\[
\mathbf{\mu}_{\text{post}} =  k(\mathbf{X}, \mathbf{X'}) \left[k(\mathbf{X}, \mathbf{X}) + \sigma^2 I \right]^{-1} Y
\]</span></p>
<p><span class="math display">\[
\mathbf{\Sigma}_{\text{post}} = k(\mathbf{X'}, \mathbf{X'}) - k(\mathbf{X'}, \mathbf{X}) \left[ k(\mathbf{X}, \mathbf{X}) + \sigma^2 I \right]^{-1} k(\mathbf{X}, \mathbf{X'})
\]</span></p>
<p>Podemos ver que la función media es una función lineal de las observaciones <span class="math inline">\(Y\)</span>. Podríamos pensar la media como <span class="math inline">\(\sum_i^n w_i(x) yi\)</span>, donde los pesos <span class="math inline">\(w\)</span> provienen de la estructura del kernel/covarianza.</p>
<p>Respecto de la covarianza a posteriori cabe destacar que es menor que la covarianza marginal <span class="math inline">\(k(\mathbf{X'}, \mathbf{X'})\)</span>. Esto es esperable ya que en general al observar datos esperamos “aprender” de ellos y por lo tanto reducir la incertidumbre a priori</p>
</section>
<section id="gps-y-pymc" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="gps-y-pymc"><span class="header-section-number">7.5</span> GPs y PyMC</h2>
<p>PyMC tiene un módulo <code>gp</code>, el cual tiene distintas implementaciones de GPs, estas implementaciones varían, por ejemplo, si el likelihood es o no Gaussiano. A fin de ejemplificar su uso, generemos un dataset sintético.</p>
<div id="181fa53d" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb15-2"><a href="#cb15-2"></a>x <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi, size<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb15-3"><a href="#cb15-3"></a>y <span class="op">=</span> np.random.normal(np.sin(x), <span class="fl">0.1</span>)</span>
<span id="cb15-4"><a href="#cb15-4"></a></span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">3</span>))</span>
<span id="cb15-7"><a href="#cb15-7"></a>ax.plot(x, y, <span class="st">'o'</span>)</span>
<span id="cb15-8"><a href="#cb15-8"></a>true_x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span> np.pi, <span class="dv">200</span>)</span>
<span id="cb15-9"><a href="#cb15-9"></a>ax.plot(true_x, np.sin(true_x), <span class="st">'C1'</span>)</span>
<span id="cb15-10"><a href="#cb15-10"></a>ax.set_xlabel(<span class="st">'x'</span>)</span>
<span id="cb15-11"><a href="#cb15-11"></a>ax.set_ylabel(<span class="st">'sin(x)'</span>, rotation<span class="op">=</span><span class="dv">0</span>, labelpad<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="f7a36f7c" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># Se espera que X tenga dimensión 2, incluso si lo tenemos una variable/feature</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>X <span class="op">=</span> x[:, <span class="va">None</span>]</span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> modelo_reg:</span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="co"># hyperprior para la longitud de escala</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    ℓ <span class="op">=</span> pm.Exponential(<span class="st">"ℓ"</span>, <span class="fl">0.5</span>)</span>
<span id="cb16-7"><a href="#cb16-7"></a>    </span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="co"># instanciamos la función de covarianza</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>    cov <span class="op">=</span> pm.gp.cov.ExpQuad(<span class="dv">1</span>, ls<span class="op">=</span>ℓ)</span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="co"># instanciamos el GP (prior)</span></span>
<span id="cb16-11"><a href="#cb16-11"></a>    gp <span class="op">=</span> pm.gp.Marginal(cov_func<span class="op">=</span>cov)</span>
<span id="cb16-12"><a href="#cb16-12"></a></span>
<span id="cb16-13"><a href="#cb16-13"></a>    σ <span class="op">=</span> pm.HalfNormal(<span class="st">'σ'</span>, <span class="dv">25</span>)</span>
<span id="cb16-14"><a href="#cb16-14"></a></span>
<span id="cb16-15"><a href="#cb16-15"></a>    y_pred <span class="op">=</span> gp.marginal_likelihood(<span class="st">'y_pred'</span>, X<span class="op">=</span>X, y<span class="op">=</span>y, sigma<span class="op">=</span>σ)</span>
<span id="cb16-16"><a href="#cb16-16"></a>    idata_reg <span class="op">=</span> pm.sample(random_seed<span class="op">=</span><span class="dv">123</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [ℓ, σ]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 4 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"1a782bf432d34ad9bb1a54d31bba2aa3","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<p>A fin de observar el ajuste vamos a evaluar el posterior GP en valores nuevos <code>X_new</code>.</p>
<div id="a74b370b" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>X_new <span class="op">=</span> np.linspace(np.floor(x.<span class="bu">min</span>()), np.ceil(x.<span class="bu">max</span>()), <span class="dv">100</span>)[:,<span class="va">None</span>]</span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="cf">with</span> modelo_reg:</span>
<span id="cb18-4"><a href="#cb18-4"></a>    f_pred <span class="op">=</span> gp.conditional(<span class="st">'f_pred'</span>, X_new)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="9706471f" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="cf">with</span> modelo_reg:</span>
<span id="cb19-2"><a href="#cb19-2"></a>    idata_reg_subset <span class="op">=</span> idata_reg.sel(draw<span class="op">=</span><span class="bu">slice</span>(<span class="dv">0</span>, <span class="va">None</span>, <span class="dv">100</span>))</span>
<span id="cb19-3"><a href="#cb19-3"></a>    pred_samples <span class="op">=</span> pm.sample_posterior_predictive(idata_reg_subset,</span>
<span id="cb19-4"><a href="#cb19-4"></a>                                                  var_names<span class="op">=</span>[<span class="st">"f_pred"</span>],</span>
<span id="cb19-5"><a href="#cb19-5"></a>                                                  random_seed<span class="op">=</span><span class="dv">123</span>)</span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a>f_pred <span class="op">=</span> az.extract(pred_samples, group<span class="op">=</span><span class="st">"posterior_predictive"</span>)[<span class="st">'f_pred'</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [f_pred]</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"700d2881613b4c1fafcbbf6960ae3344","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<p>Como vimos con modelos lineales generalizados tenemos varias opciones para visualizar el ajuste. Una de ellas es graficar la funciones resultantes, en el caso de GLMs estas eran lineas en el caso de GPs, estas serán funciones más flexibles.</p>
<div id="dd78dbf9" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="fl">3.7</span>))</span>
<span id="cb21-2"><a href="#cb21-2"></a>ax.plot(X_new, f_pred, <span class="st">'C1-'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb21-3"><a href="#cb21-3"></a>ax.plot(X, y, <span class="st">'ko'</span>)</span>
<span id="cb21-4"><a href="#cb21-4"></a>ax.set_xlabel(<span class="st">'X'</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-19-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>El módulo <code>gp</code> incluye algunas funciones para visualizar ajustes como <code>plot_gp_dist</code>. Esta función genera bandas para distinto percentiles desde 99 (azul claro) al 51 (azul oscuro).</p>
<div id="27eebe9f" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="fl">3.7</span>))</span>
<span id="cb22-2"><a href="#cb22-2"></a></span>
<span id="cb22-3"><a href="#cb22-3"></a>pm.gp.util.plot_gp_dist(ax, f_pred.T, X_new, palette<span class="op">=</span><span class="st">'Blues'</span>, plot_samples<span class="op">=</span><span class="va">False</span>)<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a></span>
<span id="cb22-5"><a href="#cb22-5"></a>ax.plot(X, y, <span class="st">'wo'</span>, mec<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb22-6"><a href="#cb22-6"></a>ax.set_xlabel(<span class="st">'x'</span>)</span>
<span id="cb22-7"><a href="#cb22-7"></a>ax.set_ylabel(<span class="st">'f(x)'</span>, rotation<span class="op">=</span><span class="dv">0</span>, labelpad<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-20-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Otra alternativa es computar el vector media y la desviación estándar como en la siguiente figura.</p>
<div id="f31f8f93" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># plot the results</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="fl">3.7</span>))</span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="co"># predict</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>point <span class="op">=</span> {<span class="st">'ℓ'</span>: idata_reg.posterior[<span class="st">'ℓ'</span>].mean(), <span class="st">'σ'</span>: idata_reg.posterior[<span class="st">'σ'</span>].mean()}</span>
<span id="cb23-6"><a href="#cb23-6"></a>mu, var <span class="op">=</span> gp.predict(X_new, point<span class="op">=</span>point, diag<span class="op">=</span><span class="va">True</span>,  model<span class="op">=</span>modelo_reg)</span>
<span id="cb23-7"><a href="#cb23-7"></a>sd <span class="op">=</span> var<span class="op">**</span><span class="fl">0.5</span></span>
<span id="cb23-8"><a href="#cb23-8"></a></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="co"># plot mean and 1σ and 2σ intervals</span></span>
<span id="cb23-10"><a href="#cb23-10"></a>ax.plot(X_new, mu, <span class="st">'C0'</span>)</span>
<span id="cb23-11"><a href="#cb23-11"></a>ax.fill_between(X_new.flatten(),</span>
<span id="cb23-12"><a href="#cb23-12"></a>                 mu <span class="op">-</span> sd, mu <span class="op">+</span> sd,</span>
<span id="cb23-13"><a href="#cb23-13"></a>                 color<span class="op">=</span><span class="st">"C1"</span>,</span>
<span id="cb23-14"><a href="#cb23-14"></a>                 alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb23-15"><a href="#cb23-15"></a></span>
<span id="cb23-16"><a href="#cb23-16"></a>ax.fill_between(X_new.flatten(),</span>
<span id="cb23-17"><a href="#cb23-17"></a>                 mu <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>sd, mu <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>sd,</span>
<span id="cb23-18"><a href="#cb23-18"></a>                 color<span class="op">=</span><span class="st">"C1"</span>,</span>
<span id="cb23-19"><a href="#cb23-19"></a>                 alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb23-20"><a href="#cb23-20"></a></span>
<span id="cb23-21"><a href="#cb23-21"></a>ax.plot(X, y, <span class="st">'ko'</span>)</span>
<span id="cb23-22"><a href="#cb23-22"></a>ax.set_xlabel(<span class="st">'X'</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-21-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="prior-para-la-longitud-de-escala" class="level2" data-number="7.6">
<h2 data-number="7.6" class="anchored" data-anchor-id="prior-para-la-longitud-de-escala"><span class="header-section-number">7.6</span> Prior para la longitud de escala</h2>
<p>Al establecer una distribución a priori para la longitud de escala, las distribuciones que evitan el cero y/o asignan poca masa a valores <em>muy pequeños</em> suelen funcionar mejor. Como ya vimos, <span class="math inline">\(\ell\)</span> controla cuan distintos son dos valores, un valor de 0 para <span class="math inline">\(\ell\)</span> implica que todo es distinto a todo. En un kernel como el cuadrático exponencial o Matern, esto implica funciones menos suaves, o que varían más rápido.</p>
<p>Además, es deseables que los valores de <span class="math inline">\(\ell\)</span> se encuentren en el rango de los datos. Para valores por debajo del espaciado mínimo de las covariables o por encima del rango de los datos el likelihood no tiene forma de distinguir entre diferentes longitud de escala. Es decir todos los valores son equivalentes y tenemos un problema de no-identificabilidad. Esto se traducirá en un GP que tenderá a sobreajustar e interpolar exactamente entre los datos de entrada y en problemas de muestreo.</p>
<p>Es por ello que es común usar distribuciones Gama o Gama Inversa ajustada <em>debilmente</em> según los datos. Para el resto del capítulo usaremos la siguiente función para estimar de forma automática la distribución a priori para <span class="math inline">\(\ell\)</span>.</p>
<div id="749d3c78" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">def</span> get_ig_params(x_vals, l_b<span class="op">=</span><span class="va">None</span>, u_b<span class="op">=</span><span class="va">None</span>, mass<span class="op">=</span><span class="fl">0.95</span>, plot<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb24-2"><a href="#cb24-2"></a>    <span class="co">"""</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="co">    Returns a weakly informative prior for the length-scale parameter of the GP kernel.</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="co">    """</span></span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a>    differences <span class="op">=</span> np.<span class="bu">abs</span>(np.subtract.outer(x_vals, x_vals))</span>
<span id="cb24-7"><a href="#cb24-7"></a>    <span class="cf">if</span> l_b <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb24-8"><a href="#cb24-8"></a>        l_b <span class="op">=</span> np.<span class="bu">min</span>(differences[differences <span class="op">!=</span> <span class="dv">0</span>]) <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="cf">if</span> u_b <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb24-10"><a href="#cb24-10"></a>        u_b <span class="op">=</span> np.<span class="bu">max</span>(differences) <span class="op">/</span> <span class="fl">1.5</span></span>
<span id="cb24-11"><a href="#cb24-11"></a></span>
<span id="cb24-12"><a href="#cb24-12"></a>    dist <span class="op">=</span> pz.InverseGamma()</span>
<span id="cb24-13"><a href="#cb24-13"></a>    pz.maxent(dist, l_b, u_b, mass, plot<span class="op">=</span>plot)</span>
<span id="cb24-14"><a href="#cb24-14"></a></span>
<span id="cb24-15"><a href="#cb24-15"></a>    <span class="cf">return</span> <span class="bu">dict</span>(<span class="bu">zip</span>(dist.param_names, dist.params))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="gps-generalizados" class="level2" data-number="7.7">
<h2 data-number="7.7" class="anchored" data-anchor-id="gps-generalizados"><span class="header-section-number">7.7</span> GPs generalizados</h2>
<p>Como vimos con los GLMs, podemos utilizar un modelo lineal con una verosimilitud no gaussiana y una función de enlace inversa adecuada para ampliar el rango de modelos lineales útiles. La misma idea aplica a los GPs. Podemos, por ejemplo, utilizar una verosimilitud de Poisson con una función inversa de enlace exponencial. Para un modelo como este, la distribución <em>a posteriori</em> ya no es analíticamente tratable, pero, no obstante, podemos utilizar métodos numéricos para aproximarla. En las siguientes secciones, analizaremos este tipo de modelos.</p>
</section>
<section id="gps-para-clasificación" class="level2" data-number="7.8">
<h2 data-number="7.8" class="anchored" data-anchor-id="gps-para-clasificación"><span class="header-section-number">7.8</span> GPs para clasificación</h2>
<p>Anteriormente vimos que una forma de crear un modelo de clasificación es usar un modelo lineal con un likelihood Bernoulli y la función logística como función inversa de enlace. Este modelo nos permite calcular la probabilidad que una observación pertenezca a la clase 1 (<span class="math inline">\(P(Y=1)\)</span>), el resultado es por lo tanto continuo (entre 0 y 1), si deseamos dicotomizarlo, podemos agregar una regla de decisión, por ej</p>
<p><span class="math display">\[
Clase = \begin{cases}
            0, &amp; P(Y=1) &lt; 0.5\\
            1, &amp; P(Y=1) &gt; =0.5
         \end{cases}
\]</span></p>
<p>Este mismo procedimiento se puede generalizar reemplazando el componente lineal por un GP.</p>
<p>Al momento de implementar el modelo en PyMC tenemos que tener en cuenta un detalle “extra”. No podemos utilizar la clase <code>pm.gp.Marginal</code>, porque esa clase está restringida a la likelihoods gaussianas, ya que aprovecha la tractabilidad matemática de la distribución a posteriori inducida por una prior GP y un likelihood Gaussiano. En cambio, necesitamos utilizar una clase más general <code>pm.gp.Latent</code>.</p>
<div id="ad81b0ae" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a>iris <span class="op">=</span> pd.read_csv(<span class="st">'datos/iris.csv'</span>)</span>
<span id="cb25-2"><a href="#cb25-2"></a>iris.head()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">sepal_length</th>
<th data-quarto-table-cell-role="th">sepal_width</th>
<th data-quarto-table-cell-role="th">petal_length</th>
<th data-quarto-table-cell-role="th">petal_width</th>
<th data-quarto-table-cell-role="th">species</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>5.1</td>
<td>3.5</td>
<td>1.4</td>
<td>0.2</td>
<td>setosa</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>4.9</td>
<td>3.0</td>
<td>1.4</td>
<td>0.2</td>
<td>setosa</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>4.7</td>
<td>3.2</td>
<td>1.3</td>
<td>0.2</td>
<td>setosa</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>4.6</td>
<td>3.1</td>
<td>1.5</td>
<td>0.2</td>
<td>setosa</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>5.0</td>
<td>3.6</td>
<td>1.4</td>
<td>0.2</td>
<td>setosa</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div id="7208a669" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a>df <span class="op">=</span> iris.query(<span class="st">"species == ('setosa', 'versicolor')"</span>)</span>
<span id="cb26-2"><a href="#cb26-2"></a>y <span class="op">=</span> pd.Categorical(df[<span class="st">'species'</span>]).codes</span>
<span id="cb26-3"><a href="#cb26-3"></a>x_1 <span class="op">=</span> df[<span class="st">'sepal_length'</span>].values</span>
<span id="cb26-4"><a href="#cb26-4"></a>X_1 <span class="op">=</span> x_1[:, <span class="va">None</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="925d5d81" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> modelo_iris:</span>
<span id="cb27-2"><a href="#cb27-2"></a>    ℓ <span class="op">=</span> pm.InverseGamma(<span class="st">'ℓ'</span>, <span class="op">**</span>get_ig_params(x_1))</span>
<span id="cb27-3"><a href="#cb27-3"></a>    cov <span class="op">=</span> pm.gp.cov.ExpQuad(<span class="dv">1</span>, ℓ)</span>
<span id="cb27-4"><a href="#cb27-4"></a>    gp <span class="op">=</span> pm.gp.Latent(cov_func<span class="op">=</span>cov)</span>
<span id="cb27-5"><a href="#cb27-5"></a>    f <span class="op">=</span> gp.prior(<span class="st">"f"</span>, X<span class="op">=</span>X_1)</span>
<span id="cb27-6"><a href="#cb27-6"></a>    </span>
<span id="cb27-7"><a href="#cb27-7"></a>    y_ <span class="op">=</span> pm.Bernoulli(<span class="st">"y_"</span>, p<span class="op">=</span>pm.math.sigmoid(f), observed<span class="op">=</span>y)</span>
<span id="cb27-8"><a href="#cb27-8"></a>    idata_iris <span class="op">=</span> pm.sample(target_accept<span class="op">=</span><span class="fl">0.85</span>, random_seed<span class="op">=</span><span class="dv">452</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [ℓ, f_rotated_]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 29 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"22f0202e1343419ca73a27d8267306b5","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<p>Como hicimos anteriormente, vamos a evaluar el GP en unos puntos nuevos <code>X_new</code></p>
<div id="86b4d790" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a>X_new <span class="op">=</span> np.linspace(np.floor(x_1.<span class="bu">min</span>()), np.ceil(x_1.<span class="bu">max</span>()), <span class="dv">200</span>)[:, <span class="va">None</span>]</span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="cf">with</span> modelo_iris:</span>
<span id="cb29-4"><a href="#cb29-4"></a>    f_pred <span class="op">=</span> gp.conditional(<span class="st">'f_pred'</span>, X_new) </span>
<span id="cb29-5"><a href="#cb29-5"></a>    idata_iris_subset <span class="op">=</span> idata_iris.sel(draw<span class="op">=</span><span class="bu">slice</span>(<span class="dv">0</span>, <span class="va">None</span>, <span class="dv">100</span>))</span>
<span id="cb29-6"><a href="#cb29-6"></a>    pred_samples <span class="op">=</span> pm.sample_posterior_predictive(idata_iris_subset, var_names<span class="op">=</span>[<span class="st">"f_pred"</span>], random_seed<span class="op">=</span><span class="dv">123</span>)</span>
<span id="cb29-7"><a href="#cb29-7"></a></span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a>f_pred_iris <span class="op">=</span> az.extract(pred_samples, group<span class="op">=</span><span class="st">"posterior_predictive"</span>)[<span class="st">'f_pred'</span>].values</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [f_pred]</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"e78ee25279dd49b18b0508008a8fa648","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<p>La siguiente figura muestra el resultado del ajuste. La figura es muy similar a la obtenida en el capítulo de GLMs (<a href="05_GLMS.html" class="quarto-xref"><span>Capítulo 5</span></a>).</p>
<div id="826f70d3" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb31-2"><a href="#cb31-2"></a></span>
<span id="cb31-3"><a href="#cb31-3"></a>fp <span class="op">=</span> logistic(f_pred_iris)</span>
<span id="cb31-4"><a href="#cb31-4"></a>fp_mean <span class="op">=</span> np.mean(fp, <span class="dv">1</span>)</span>
<span id="cb31-5"><a href="#cb31-5"></a></span>
<span id="cb31-6"><a href="#cb31-6"></a>ax.plot(X_new[:, <span class="dv">0</span>], fp_mean)</span>
<span id="cb31-7"><a href="#cb31-7"></a>ax.scatter(x_1, np.random.normal(y, <span class="fl">0.02</span>),</span>
<span id="cb31-8"><a href="#cb31-8"></a>           marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span>[<span class="ss">f'</span><span class="sc">{</span><span class="dv">1</span><span class="op">/</span>(x<span class="op">+</span><span class="dv">2</span>)<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> y])</span>
<span id="cb31-9"><a href="#cb31-9"></a></span>
<span id="cb31-10"><a href="#cb31-10"></a>az.plot_hdi(X_new[:, <span class="dv">0</span>], fp.T, color<span class="op">=</span><span class="st">'C0'</span>)</span>
<span id="cb31-11"><a href="#cb31-11"></a></span>
<span id="cb31-12"><a href="#cb31-12"></a>decision_boundary <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb31-13"><a href="#cb31-13"></a>db <span class="op">=</span> X_new[:,<span class="dv">0</span>][np.argmin(np.<span class="bu">abs</span>(fp <span class="op">-</span> decision_boundary), <span class="dv">0</span>)]</span>
<span id="cb31-14"><a href="#cb31-14"></a>db_mean <span class="op">=</span> db.mean()</span>
<span id="cb31-15"><a href="#cb31-15"></a>db_hdi <span class="op">=</span> az.hdi(db)</span>
<span id="cb31-16"><a href="#cb31-16"></a>ax.vlines(db_mean, <span class="dv">0</span>, <span class="dv">1</span>, color<span class="op">=</span><span class="st">'C2'</span>, zorder<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb31-17"><a href="#cb31-17"></a>ax.fill_betweenx([<span class="dv">0</span>, <span class="dv">1</span>], db_hdi[<span class="dv">0</span>], db_hdi[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'C2'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, zorder<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb31-18"><a href="#cb31-18"></a>ax.set_xlabel(<span class="st">'sepal_length'</span>)</span>
<span id="cb31-19"><a href="#cb31-19"></a>ax.set_ylabel(<span class="st">'θ'</span>, rotation<span class="op">=</span><span class="dv">0</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>/home/osvaldo/anaconda3/envs/EI2/lib/python3.11/site-packages/arviz/plots/hdiplot.py:161: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions
  hdi_data = hdi(y, hdi_prob=hdi_prob, circular=circular, multimodal=False, **hdi_kwargs)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-27-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Una diferencia con el resultado de la regresión logística es el comportamiento de las colas en la curva sigmoidea, la curva no va hacia 0 para valores bajos de <code>sepal_length</code> ni hacia 1 para valores altos. Si nuestra única preocupación es el límite de decisión, entonces el comportamiento en las colas puede ser irrelevante. Pero si queremos modelar las probabilidades de pertenecer a setosa o versicolor en diferentes valores de <code>sepal_length</code>, deberíamos hacer algo para mejorar el modelo en las colas.</p>
<p>Un primer paso para solucionar el comportamiento de las colas es entender la razón por la cual sucede. Cuando hay pocos o ningún dato disponible, la distribución a posterior para un GP tenderá a <em>revertir</em> hacia la función a priori. Esto tiene sentido si pensamos que, en ausencia de datos, cualquier distribución a posteriori debería ser esencialmente la distribución a priori.</p>
<p>Una característica que le da mayor versatilidad a los GPs, es que es posible combinar kernel y obtener nuevos comportamientos. A continuación vamos a crear un modelo que combina 3 kernels:</p>
<ul>
<li>cuadrático exponencial</li>
<li>lineal</li>
<li>ruido blanco</li>
</ul>
<p>La función del kernel lineal sera hacer que las colas vayan a 0 o 1 en los límites de los datos. La función del kernel de ruido blanco es estabilizar el cálculo de la matriz de covarianza. Agregar un poco de ruido es un truco numérico que ayuda a garantizar que la matriz de covarianza sea válida. De hecho, PyMC internamente utiliza este ruido, pero a veces es necesario agregar un poco más de ruido.</p>
<div id="28c397a0" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_iris2:</span>
<span id="cb33-2"><a href="#cb33-2"></a>    ℓ <span class="op">=</span> pm.InverseGamma(<span class="st">'ℓ'</span>, <span class="op">**</span>get_ig_params(x_1))</span>
<span id="cb33-3"><a href="#cb33-3"></a>    c <span class="op">=</span> pm.Normal(<span class="st">'c'</span>, x_1.<span class="bu">min</span>())</span>
<span id="cb33-4"><a href="#cb33-4"></a>    τ <span class="op">=</span> pm.HalfNormal(<span class="st">'τ'</span>, <span class="dv">5</span>)</span>
<span id="cb33-5"><a href="#cb33-5"></a>    cov <span class="op">=</span> (pm.gp.cov.ExpQuad(<span class="dv">1</span>, ℓ) <span class="op">+</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>           τ <span class="op">*</span> pm.gp.cov.Linear(<span class="dv">1</span>, c) <span class="op">+</span></span>
<span id="cb33-7"><a href="#cb33-7"></a>           pm.gp.cov.WhiteNoise(<span class="fl">1E-5</span>))</span>
<span id="cb33-8"><a href="#cb33-8"></a>    gp <span class="op">=</span> pm.gp.Latent(cov_func<span class="op">=</span>cov)</span>
<span id="cb33-9"><a href="#cb33-9"></a>    f <span class="op">=</span> gp.prior(<span class="st">"f"</span>, X<span class="op">=</span>X_1)</span>
<span id="cb33-10"><a href="#cb33-10"></a></span>
<span id="cb33-11"><a href="#cb33-11"></a>    y_ <span class="op">=</span> pm.Bernoulli(<span class="st">"y"</span>, p<span class="op">=</span>pm.math.sigmoid(f), observed<span class="op">=</span>y)</span>
<span id="cb33-12"><a href="#cb33-12"></a>    idata_iris2 <span class="op">=</span> pm.sample(target_accept<span class="op">=</span><span class="fl">0.9</span>, random_seed<span class="op">=</span><span class="dv">452</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [ℓ, c, τ, f_rotated_]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 66 seconds.
There were 3 divergences after tuning. Increase `target_accept` or reparameterize.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"1a0688e0733142f1afb09a613f5edc64","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<div id="989b2076" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a>X_new <span class="op">=</span> np.linspace(np.floor(x_1.<span class="bu">min</span>()), np.ceil(x_1.<span class="bu">max</span>()), <span class="dv">100</span>)[:, <span class="va">None</span>]</span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="cf">with</span> model_iris2:</span>
<span id="cb35-3"><a href="#cb35-3"></a>    f_pred <span class="op">=</span> gp.conditional(<span class="st">'f_pred'</span>, X_new) </span>
<span id="cb35-4"><a href="#cb35-4"></a>    idata_iris2_subset <span class="op">=</span> idata_iris2.sel(draw<span class="op">=</span><span class="bu">slice</span>(<span class="dv">0</span>, <span class="va">None</span>, <span class="dv">100</span>))</span>
<span id="cb35-5"><a href="#cb35-5"></a>    pred_samples2 <span class="op">=</span> pm.sample_posterior_predictive(idata_iris2_subset,</span>
<span id="cb35-6"><a href="#cb35-6"></a>                                                   var_names<span class="op">=</span>[<span class="st">"f_pred"</span>],</span>
<span id="cb35-7"><a href="#cb35-7"></a>                                                   random_seed<span class="op">=</span><span class="dv">123</span>)  </span>
<span id="cb35-8"><a href="#cb35-8"></a></span>
<span id="cb35-9"><a href="#cb35-9"></a></span>
<span id="cb35-10"><a href="#cb35-10"></a>f_pred_iris2 <span class="op">=</span> az.extract(pred_samples2, group<span class="op">=</span><span class="st">"posterior_predictive"</span>)[<span class="st">'f_pred'</span>].values         </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [f_pred]</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"b2ca63a14b1f43de93fcbaf13d1067b8","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<p>El resultado lo podemos ver en la siguiente figura:</p>
<div id="a1243d20" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a>fp <span class="op">=</span> logistic(f_pred_iris2)</span>
<span id="cb37-4"><a href="#cb37-4"></a>fp_mean <span class="op">=</span> np.mean(fp, <span class="dv">1</span>)</span>
<span id="cb37-5"><a href="#cb37-5"></a></span>
<span id="cb37-6"><a href="#cb37-6"></a>ax.plot(X_new[:, <span class="dv">0</span>], fp_mean)</span>
<span id="cb37-7"><a href="#cb37-7"></a></span>
<span id="cb37-8"><a href="#cb37-8"></a>ax.scatter(x_1, np.random.normal(y, <span class="fl">0.02</span>),</span>
<span id="cb37-9"><a href="#cb37-9"></a>           marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span>[<span class="ss">f'</span><span class="sc">{</span><span class="dv">1</span><span class="op">/</span>(x<span class="op">+</span><span class="dv">2</span>)<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> y])</span>
<span id="cb37-10"><a href="#cb37-10"></a></span>
<span id="cb37-11"><a href="#cb37-11"></a>az.plot_hdi(X_new[:, <span class="dv">0</span>], fp.T, color<span class="op">=</span><span class="st">'C0'</span>)</span>
<span id="cb37-12"><a href="#cb37-12"></a></span>
<span id="cb37-13"><a href="#cb37-13"></a>decision_boundary <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb37-14"><a href="#cb37-14"></a>db <span class="op">=</span> X_new[:,<span class="dv">0</span>][np.argmin(np.<span class="bu">abs</span>(fp <span class="op">-</span> decision_boundary), <span class="dv">0</span>)]</span>
<span id="cb37-15"><a href="#cb37-15"></a>db_mean <span class="op">=</span> db.mean()</span>
<span id="cb37-16"><a href="#cb37-16"></a>db_hdi <span class="op">=</span> az.hdi(db)</span>
<span id="cb37-17"><a href="#cb37-17"></a>ax.vlines(db_mean, <span class="dv">0</span>, <span class="dv">1</span>, color<span class="op">=</span><span class="st">'C2'</span>, zorder<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb37-18"><a href="#cb37-18"></a>ax.fill_betweenx([<span class="dv">0</span>, <span class="dv">1</span>], db_hdi[<span class="dv">0</span>], db_hdi[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'C2'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, zorder<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb37-19"><a href="#cb37-19"></a>ax.set_xlabel(<span class="st">'sepal_length'</span>)</span>
<span id="cb37-20"><a href="#cb37-20"></a>ax.set_ylabel(<span class="st">'θ'</span>, rotation<span class="op">=</span><span class="dv">0</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/osvaldo/anaconda3/envs/EI2/lib/python3.11/site-packages/arviz/plots/hdiplot.py:161: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions
  hdi_data = hdi(y, hdi_prob=hdi_prob, circular=circular, multimodal=False, **hdi_kwargs)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-30-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>El ejemplo anterior ilustra que es posible generalizar la aplicación de los GP, de forma similar a los GLMs, pero en la práctica no tiene demasiado sentido utilizar un GP para hacer el trabajo que tranquilamente podemos resolver con una regresión logística. En cambio, queremos utilizar GPs para modelar datos más complejos que no se capturan bien con modelos menos flexibles. Supongamos que queremos modelar la probabilidad de contraer una enfermedad en función de la edad. Resulta que las personas muy jóvenes y muy mayores tienen un riesgo mayor que las personas de mediana edad. El conjunto de datos <code>gripe_espacial</code> es un conjunto de datos sintético inspirado en la descripción anterior. La siguiente figura muestra estos datos.</p>
<div id="5e48270d" class="cell" data-execution_count="30">
<details class="code-fold">
<summary>Mostrar Código</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1"></a>df_sf <span class="op">=</span> pd.read_csv(<span class="st">'datos/gripe_espacial.csv'</span>)</span>
<span id="cb39-2"><a href="#cb39-2"></a>age <span class="op">=</span> df_sf.age.values[:, <span class="va">None</span>]</span>
<span id="cb39-3"><a href="#cb39-3"></a>space_flu <span class="op">=</span> df_sf.space_flu</span>
<span id="cb39-4"><a href="#cb39-4"></a></span>
<span id="cb39-5"><a href="#cb39-5"></a>ax <span class="op">=</span> df_sf.plot.scatter(<span class="st">'age'</span>, <span class="st">'space_flu'</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb39-6"><a href="#cb39-6"></a>ax.set_ylabel(<span class="st">""</span>)</span>
<span id="cb39-7"><a href="#cb39-7"></a>ax.set_xlabel(<span class="st">"edad"</span>)</span>
<span id="cb39-8"><a href="#cb39-8"></a>ax.set_title(<span class="st">"Gripe espacial"</span>)</span>
<span id="cb39-9"><a href="#cb39-9"></a>ax.set_yticks([<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb39-10"><a href="#cb39-10"></a>ax.set_yticklabels([<span class="st">'sano'</span>, <span class="st">'enfermo'</span>])<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-31-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="9ed73199" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> modelo_gripe_espacial:</span>
<span id="cb40-2"><a href="#cb40-2"></a>    ℓ <span class="op">=</span> pm.InverseGamma(<span class="st">'ℓ'</span>, <span class="op">**</span>get_ig_params(age))</span>
<span id="cb40-3"><a href="#cb40-3"></a>    cov <span class="op">=</span> pm.gp.cov.ExpQuad(<span class="dv">1</span>, ℓ) <span class="op">+</span> pm.gp.cov.WhiteNoise(<span class="fl">1E-5</span>)</span>
<span id="cb40-4"><a href="#cb40-4"></a>    gp <span class="op">=</span> pm.gp.Latent(cov_func<span class="op">=</span>cov)</span>
<span id="cb40-5"><a href="#cb40-5"></a>    f <span class="op">=</span> gp.prior(<span class="st">'f'</span>, X<span class="op">=</span>age)</span>
<span id="cb40-6"><a href="#cb40-6"></a>    y_ <span class="op">=</span> pm.Bernoulli(<span class="st">'y'</span>, p<span class="op">=</span>pm.math.sigmoid(f), observed<span class="op">=</span>space_flu)</span>
<span id="cb40-7"><a href="#cb40-7"></a>    idata_gripe_espacial <span class="op">=</span> pm.sample(random_seed<span class="op">=</span><span class="dv">123</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [ℓ, f_rotated_]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 10 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"1e39ba0110514a57a5dc9125b4125b77","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<div id="80b9b78e" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1"></a>X_new <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">80</span>, <span class="dv">60</span>)[:, <span class="va">None</span>]</span>
<span id="cb42-2"><a href="#cb42-2"></a></span>
<span id="cb42-3"><a href="#cb42-3"></a>    </span>
<span id="cb42-4"><a href="#cb42-4"></a><span class="cf">with</span> modelo_gripe_espacial:</span>
<span id="cb42-5"><a href="#cb42-5"></a>    f_pred <span class="op">=</span> gp.conditional(<span class="st">'f_pred'</span>, X_new) </span>
<span id="cb42-6"><a href="#cb42-6"></a>    idata_gripe_espacial_subset <span class="op">=</span> idata_gripe_espacial.sel(draw<span class="op">=</span><span class="bu">slice</span>(<span class="dv">0</span>, <span class="va">None</span>, <span class="dv">100</span>))</span>
<span id="cb42-7"><a href="#cb42-7"></a>    pred_samples_gripe <span class="op">=</span> pm.sample_posterior_predictive(idata_gripe_espacial, var_names<span class="op">=</span>[<span class="st">"f_pred"</span>],</span>
<span id="cb42-8"><a href="#cb42-8"></a>                                                        random_seed<span class="op">=</span><span class="dv">123</span>)</span>
<span id="cb42-9"><a href="#cb42-9"></a></span>
<span id="cb42-10"><a href="#cb42-10"></a></span>
<span id="cb42-11"><a href="#cb42-11"></a>f_pred_gripe_espacial <span class="op">=</span> az.extract(pred_samples_gripe, group<span class="op">=</span><span class="st">"posterior_predictive"</span>)[<span class="st">'f_pred'</span>].values</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Sampling: [f_pred]</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"501e3556586e4b469c6811581be7ad7d","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<p>Ajustar bien estos datos es imposible para una regresión logística simple, a menos que introduzcamos algunas modificaciones <em>ad hoc</em> para ayudar un poco (ver el ejercicio 6 al final del capítulo para una discusión de dichas modificaciones).</p>
<div id="dd76970b" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb44-2"><a href="#cb44-2"></a></span>
<span id="cb44-3"><a href="#cb44-3"></a>fp <span class="op">=</span> logistic(f_pred_gripe_espacial)</span>
<span id="cb44-4"><a href="#cb44-4"></a>fp_mean <span class="op">=</span> np.nanmean(fp, <span class="dv">1</span>)</span>
<span id="cb44-5"><a href="#cb44-5"></a></span>
<span id="cb44-6"><a href="#cb44-6"></a>ax.scatter(age, np.random.normal(space_flu, <span class="fl">0.02</span>),</span>
<span id="cb44-7"><a href="#cb44-7"></a>           marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span>[<span class="ss">f'C</span><span class="sc">{</span>ci<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> ci <span class="kw">in</span> space_flu])</span>
<span id="cb44-8"><a href="#cb44-8"></a></span>
<span id="cb44-9"><a href="#cb44-9"></a>ax.plot(X_new[:, <span class="dv">0</span>], fp_mean, <span class="st">'C2'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb44-10"><a href="#cb44-10"></a></span>
<span id="cb44-11"><a href="#cb44-11"></a>az.plot_hdi(X_new[:, <span class="dv">0</span>], fp.T, color<span class="op">=</span><span class="st">'C2'</span>, smooth<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb44-12"><a href="#cb44-12"></a>ax.set_yticks([<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb44-13"><a href="#cb44-13"></a>ax.set_yticklabels([<span class="st">'sano'</span>, <span class="st">'enfermo'</span>])</span>
<span id="cb44-14"><a href="#cb44-14"></a>ax.set_xlabel(<span class="st">'edad'</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/osvaldo/anaconda3/envs/EI2/lib/python3.11/site-packages/arviz/plots/hdiplot.py:161: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions
  hdi_data = hdi(y, hdi_prob=hdi_prob, circular=circular, multimodal=False, **hdi_kwargs)</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>Text(0.5, 0, 'edad')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-34-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="cox-processes" class="level2" data-number="7.9">
<h2 data-number="7.9" class="anchored" data-anchor-id="cox-processes"><span class="header-section-number">7.9</span> Cox processes</h2>
<p>Ahora vamos a modelar datos de conteo. Para ello, utilizaremos la distribución de Poisson como likelihood y la tasa se modelará utilizando un proceso gaussiano. Debido a que la tasa de la distribución de Poisson está limitada a valores positivos, utilizaremos una función exponencial como función de enlace inversa.</p>
<p>En la literatura es común encontrar este tipo de modelos bajo el nombre de proceso de Poisson o proceso de Cox. Un proceso de Poisson es un proceso estocástico donde cada conjunto finito de puntos se distribuye siguiendo una Poisson. Cuando la tasa del proceso de Poisson es en sí misma un proceso estocástico, como, por ejemplo, un proceso gaussiano, entonces tenemos un proceso de Cox.</p>
<p>Para ilustrar este ejemplo usaremos el conjunto de datos de los accidentes mineros que ya vimos anteriormente. Solo que en este caso haremos uso, solamente de una columna de datos, donde cada entrada corresponde con el tiempo (en años) en el que ocurrió cada accidente.</p>
<div id="f32e58a1" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a>coal_df <span class="op">=</span> pd.read_csv(<span class="st">'datos/coal.csv'</span>, header<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb47-2"><a href="#cb47-2"></a>coal_df.head()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1851.2026</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1851.6324</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1851.9692</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1851.9747</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1852.3142</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<p>Hemos venido usando GPs para hacer regresión, pero ¿Cómo vamos a realizar una regresión si solo tenemos una única columna de datos?. La respuesta es discretizar los datos, como si estuviéramos construyendo un histograma. Vamos a utilizar los centros de los intervalos como la variable <span class="math inline">\(X\)</span> y los conteos por intervalo como la variable <span class="math inline">\(Y\)</span>.</p>
<div id="f86ee8af" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a><span class="co"># discretizamos los datos</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>years <span class="op">=</span> <span class="bu">int</span>((coal_df.<span class="bu">max</span>() <span class="op">-</span> coal_df.<span class="bu">min</span>()).iloc[<span class="dv">0</span>])</span>
<span id="cb48-3"><a href="#cb48-3"></a>bins <span class="op">=</span> years <span class="op">//</span> <span class="dv">4</span></span>
<span id="cb48-4"><a href="#cb48-4"></a>hist, x_edges <span class="op">=</span> np.histogram(coal_df, bins<span class="op">=</span>bins)</span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="co"># calculamos la ubicación de los centros de los datos discretizados</span></span>
<span id="cb48-6"><a href="#cb48-6"></a>x_centers <span class="op">=</span> x_edges[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> (x_edges[<span class="dv">1</span>] <span class="op">-</span> x_edges[<span class="dv">0</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="co"># xdata tiene que ser 2D para los GPS</span></span>
<span id="cb48-8"><a href="#cb48-8"></a>x_data <span class="op">=</span> x_centers[:, <span class="va">None</span>]</span>
<span id="cb48-9"><a href="#cb48-9"></a>y_data <span class="op">=</span> hist</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora que tenemos los datos pre-procesados podemos escribir el modelo</p>
<div id="415ca3c8" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> modelo_minas:</span>
<span id="cb49-2"><a href="#cb49-2"></a>    ℓ <span class="op">=</span> pm.InverseGamma(<span class="st">'ℓ'</span>, <span class="op">**</span>get_ig_params(x_edges))</span>
<span id="cb49-3"><a href="#cb49-3"></a>    cov <span class="op">=</span> pm.gp.cov.ExpQuad(<span class="dv">1</span>, ls<span class="op">=</span>ℓ) <span class="op">+</span> pm.gp.cov.WhiteNoise(<span class="fl">1E-5</span>)</span>
<span id="cb49-4"><a href="#cb49-4"></a>    gp <span class="op">=</span> pm.gp.Latent(cov_func<span class="op">=</span>cov)</span>
<span id="cb49-5"><a href="#cb49-5"></a>    f <span class="op">=</span> gp.prior(<span class="st">'f'</span>, X<span class="op">=</span>x_data)</span>
<span id="cb49-6"><a href="#cb49-6"></a></span>
<span id="cb49-7"><a href="#cb49-7"></a>    y_pred <span class="op">=</span> pm.Poisson(<span class="st">'y_pred'</span>, mu<span class="op">=</span>pm.math.exp(f), observed<span class="op">=</span>y_data)</span>
<span id="cb49-8"><a href="#cb49-8"></a>    idata_minas <span class="op">=</span> pm.sample(random_seed<span class="op">=</span><span class="dv">123</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [ℓ, f_rotated_]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 20 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"94bbd2869c274090894a6dc2dbeac83a","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<p>La siguiente figura muestra la tasa media de desastres en función del tiempo (línea blanca). Las bandas describen el HDI del 50% (más oscuro) y el del 94% (más claro). En la parte inferior, los marcadores negros indican el momento de cada accidente. Como podemos ver, la tasa de accidentes disminuye con el tiempo, a excepción de un breve aumento inicial.</p>
<div id="369875dd" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a>_, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">5</span>))</span>
<span id="cb51-2"><a href="#cb51-2"></a></span>
<span id="cb51-3"><a href="#cb51-3"></a>f_trace <span class="op">=</span> np.exp(idata_minas.posterior[<span class="st">'f'</span>].stack(samples<span class="op">=</span>(<span class="st">"chain"</span>, <span class="st">"draw"</span>)).T) <span class="op">/</span> <span class="dv">4</span></span>
<span id="cb51-4"><a href="#cb51-4"></a>rate_median <span class="op">=</span> np.median(f_trace, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-5"><a href="#cb51-5"></a></span>
<span id="cb51-6"><a href="#cb51-6"></a>ax.plot(x_centers, rate_median, <span class="st">'w'</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb51-7"><a href="#cb51-7"></a>az.plot_hdi(x_centers, f_trace)</span>
<span id="cb51-8"><a href="#cb51-8"></a></span>
<span id="cb51-9"><a href="#cb51-9"></a>az.plot_hdi(x_centers, f_trace, hdi_prob<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb51-10"><a href="#cb51-10"></a>            plot_kwargs<span class="op">=</span>{<span class="st">'alpha'</span>: <span class="dv">0</span>})</span>
<span id="cb51-11"><a href="#cb51-11"></a></span>
<span id="cb51-12"><a href="#cb51-12"></a>ax.plot(coal_df, np.zeros_like(coal_df)<span class="op">-</span><span class="fl">0.5</span>, <span class="st">'k|'</span>)</span>
<span id="cb51-13"><a href="#cb51-13"></a>ax.set_xlabel(<span class="st">'años'</span>)</span>
<span id="cb51-14"><a href="#cb51-14"></a>ax.set_ylabel(<span class="st">'tasa'</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/osvaldo/anaconda3/envs/EI2/lib/python3.11/site-packages/arviz/plots/hdiplot.py:161: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions
  hdi_data = hdi(y, hdi_prob=hdi_prob, circular=circular, multimodal=False, **hdi_kwargs)
/home/osvaldo/anaconda3/envs/EI2/lib/python3.11/site-packages/arviz/plots/hdiplot.py:161: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions
  hdi_data = hdi(y, hdi_prob=hdi_prob, circular=circular, multimodal=False, **hdi_kwargs)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-38-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="regresión-con-autocorrelación-espacial" class="level2" data-number="7.10">
<h2 data-number="7.10" class="anchored" data-anchor-id="regresión-con-autocorrelación-espacial"><span class="header-section-number">7.10</span> Regresión con autocorrelación espacial</h2>
<p>El siguiente ejemplo es una modificación de un ejemplo discutido en <em>Statistical Rethinking</em>.</p>
<p>Para este ejemplo, tenemos 10 sociedades insulares diferentes; para cada una de ellas, tenemos la cantidad de herramientas que utilizan. Algunas teorías predicen que las poblaciones más grandes desarrollan y mantienen más herramientas que las poblaciones más pequeñas. Por lo tanto, podemos pensar un problema de regresión donde la variable dependiente es la cantidad de herramientas y la variable independiente es la población. Como el número de herramientas es una variable de conteo, podemos utilizar una distribución de Poisson. Además, tenemos buenas razones teóricas para pensar que el logaritmo de la población es una mejor variable que el tamaño absoluto porque lo que realmente importa (según la teoría) es el orden de magnitud de la población.</p>
<p>Hasta ahora, el modelo que tenemos en mente es una regresión de Poisson, pero aquí viene la parte interesante. Otro factor importante que afecta al número de herramientas son las tasas de contacto entre las sociedades insulares. Una forma de incluir la tasa de contacto en nuestro modelo es recopilar información sobre la frecuencia con la que estas sociedades estuvieron en contacto a lo largo de la historia y crear una variable categórica como tasa baja/alta. Pero obtener dicha información no es una tarea sencilla. Una alternativa es utilizar la distancia entre islas como un indicador de la tasa de contacto, ya que es razonable suponer que las sociedades geográficamente cercanas entran en contacto con más frecuencia que las distantes.</p>
<p>La cantidad de herramientas, el tamaño de la población y las coordenadas se almacenan en el archivo <code>islands.csv</code></p>
<p>Omitiendo priors, el modelo que vamos a construir es:</p>
<p><span class="math display">\[
\begin{align*}
    f &amp;\sim \mathcal{GP}([0, \dots, 0], \kappa(X, X')) \\
    \mu &amp;\sim \exp(\alpha + \beta X + f) \\
    Y &amp;= \text{Pois}(\mu)
\end{align*}
\]</span></p>
<p>Este modelo es un modelo lineal más un término GP. Usamos la parte lineal para modelar el efecto del logaritmo de la población y el término GP para modelar el efecto del contacto entre sociedades. Es decir modelaremos el número de herramientas en cada sociedad como una función de su distribución espacial.</p>
<p>La información sobre la distribución espacial está en términos de latitudes y longitudes, pero los kernels en PyMC suponen que las distancias son todas euclídias. Por lo que vamos a tener que crear un nuevo kernel con una distancia más adecuada.</p>
<p>La distancia de Haversine determina la distancia del círculo máximo entre dos puntos en una esfera dadas sus longitudes y latitudes. La distancia del círculo máximo es la distancia más corta entre dos puntos en la superficie de una esfera medida a lo largo de la superficie de la esfera.</p>
<div id="b5631f51" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a>islands <span class="op">=</span> pd.read_csv(<span class="st">'datos/islands.csv'</span>)</span>
<span id="cb53-2"><a href="#cb53-2"></a>islands.head().<span class="bu">round</span>(<span class="dv">1</span>)</span>
<span id="cb53-3"><a href="#cb53-3"></a>X <span class="op">=</span> islands[[<span class="st">"lat"</span>, <span class="st">"lon"</span>]].values</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="84b4601d" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">def</span> haversine_distance(lat, lon, r<span class="op">=</span><span class="fl">6.371</span>):</span>
<span id="cb54-2"><a href="#cb54-2"></a></span>
<span id="cb54-3"><a href="#cb54-3"></a>    lat <span class="op">=</span> np.radians(lat)</span>
<span id="cb54-4"><a href="#cb54-4"></a>    lon <span class="op">=</span> np.radians(lon)</span>
<span id="cb54-5"><a href="#cb54-5"></a>    </span>
<span id="cb54-6"><a href="#cb54-6"></a>    latd <span class="op">=</span> lat[:,<span class="va">None</span>] <span class="op">-</span> lat</span>
<span id="cb54-7"><a href="#cb54-7"></a>    lond <span class="op">=</span> lon[:,<span class="va">None</span>] <span class="op">-</span> lon</span>
<span id="cb54-8"><a href="#cb54-8"></a></span>
<span id="cb54-9"><a href="#cb54-9"></a>    d <span class="op">=</span> np.cos(lat[:,<span class="va">None</span>]) <span class="op">*</span> np.cos(lat)</span>
<span id="cb54-10"><a href="#cb54-10"></a>    a <span class="op">=</span> np.sin(latd <span class="op">/</span> <span class="dv">2</span>)<span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> d <span class="op">*</span> np.sin(lond <span class="op">/</span> <span class="dv">2</span>)<span class="op">**</span> <span class="dv">2</span></span>
<span id="cb54-11"><a href="#cb54-11"></a>    c <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.arctan2(np.sqrt(a), np.sqrt(<span class="dv">1</span> <span class="op">-</span> a))</span>
<span id="cb54-12"><a href="#cb54-12"></a></span>
<span id="cb54-13"><a href="#cb54-13"></a>    <span class="cf">return</span> r <span class="op">*</span> c</span>
<span id="cb54-14"><a href="#cb54-14"></a></span>
<span id="cb54-15"><a href="#cb54-15"></a>islands_dist <span class="op">=</span> haversine_distance(X[:,<span class="dv">0</span>], X[:,<span class="dv">1</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fb437410" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">class</span> ExpQuadHaversine(pm.gp.cov.Stationary):</span>
<span id="cb55-2"><a href="#cb55-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_dims, ls, ls_inv<span class="op">=</span><span class="va">None</span>, r<span class="op">=</span><span class="fl">6.371</span>, active_dims<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb55-3"><a href="#cb55-3"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(input_dims, ls<span class="op">=</span>ls,  ls_inv<span class="op">=</span>ls_inv, active_dims<span class="op">=</span>active_dims)</span>
<span id="cb55-4"><a href="#cb55-4"></a>        <span class="va">self</span>.r <span class="op">=</span> r <span class="co"># earth radius in thousands of km</span></span>
<span id="cb55-5"><a href="#cb55-5"></a></span>
<span id="cb55-6"><a href="#cb55-6"></a>    <span class="kw">def</span> haversine_distance(<span class="va">self</span>, X):</span>
<span id="cb55-7"><a href="#cb55-7"></a></span>
<span id="cb55-8"><a href="#cb55-8"></a>        lat <span class="op">=</span> np.radians(X[:, <span class="dv">0</span>])</span>
<span id="cb55-9"><a href="#cb55-9"></a>        lon <span class="op">=</span> np.radians(X[:, <span class="dv">1</span>])</span>
<span id="cb55-10"><a href="#cb55-10"></a></span>
<span id="cb55-11"><a href="#cb55-11"></a>        latd <span class="op">=</span> lat[:,<span class="va">None</span>] <span class="op">-</span> lat</span>
<span id="cb55-12"><a href="#cb55-12"></a>        lond <span class="op">=</span> lon[:,<span class="va">None</span>] <span class="op">-</span> lon</span>
<span id="cb55-13"><a href="#cb55-13"></a></span>
<span id="cb55-14"><a href="#cb55-14"></a>        d <span class="op">=</span> pt.cos(lat[:,<span class="va">None</span>]) <span class="op">*</span> pt.cos(lat)</span>
<span id="cb55-15"><a href="#cb55-15"></a>        a <span class="op">=</span> pt.sin(latd <span class="op">/</span> <span class="dv">2</span>)<span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> d <span class="op">*</span> pt.sin(lond <span class="op">/</span> <span class="dv">2</span>)<span class="op">**</span> <span class="dv">2</span></span>
<span id="cb55-16"><a href="#cb55-16"></a>        c <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> pt.arctan2(pt.sqrt(a), pt.sqrt(<span class="dv">1</span> <span class="op">-</span> a))</span>
<span id="cb55-17"><a href="#cb55-17"></a></span>
<span id="cb55-18"><a href="#cb55-18"></a>        <span class="cf">return</span> <span class="va">self</span>.r <span class="op">*</span> c</span>
<span id="cb55-19"><a href="#cb55-19"></a></span>
<span id="cb55-20"><a href="#cb55-20"></a>    <span class="kw">def</span> full(<span class="va">self</span>, X, _):</span>
<span id="cb55-21"><a href="#cb55-21"></a>        <span class="cf">return</span> pt.exp(<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.haversine_distance(X))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="3dad590e" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1"></a>culture_labels <span class="op">=</span> islands.culture.values</span>
<span id="cb56-2"><a href="#cb56-2"></a>index <span class="op">=</span> islands.index.values</span>
<span id="cb56-3"><a href="#cb56-3"></a>log_pop <span class="op">=</span> islands.logpop</span>
<span id="cb56-4"><a href="#cb56-4"></a>total_tools <span class="op">=</span> islands.total_tools</span>
<span id="cb56-5"><a href="#cb56-5"></a>x_data <span class="op">=</span> [islands.lat.values[:, <span class="va">None</span>], islands.lon.values[:, <span class="va">None</span>]]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="332c4e5b" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_islands:</span>
<span id="cb57-2"><a href="#cb57-2"></a>    η <span class="op">=</span> pm.Exponential(<span class="st">'η'</span>, <span class="dv">2</span>)</span>
<span id="cb57-3"><a href="#cb57-3"></a>    ℓ <span class="op">=</span> pm.InverseGamma(<span class="st">'ℓ'</span>, <span class="op">**</span>get_ig_params(islands_dist))</span>
<span id="cb57-4"><a href="#cb57-4"></a>    </span>
<span id="cb57-5"><a href="#cb57-5"></a>    cov <span class="op">=</span> η <span class="op">*</span> ExpQuadHaversine(<span class="dv">2</span>, ls<span class="op">=</span>ℓ)</span>
<span id="cb57-6"><a href="#cb57-6"></a>    gp <span class="op">=</span> pm.gp.Latent(cov_func<span class="op">=</span>cov)</span>
<span id="cb57-7"><a href="#cb57-7"></a>    f <span class="op">=</span> gp.prior(<span class="st">'f'</span>, X<span class="op">=</span>X)</span>
<span id="cb57-8"><a href="#cb57-8"></a></span>
<span id="cb57-9"><a href="#cb57-9"></a>    α <span class="op">=</span> pm.Normal(<span class="st">'α'</span>, <span class="dv">0</span>, <span class="dv">5</span>)</span>
<span id="cb57-10"><a href="#cb57-10"></a>    β <span class="op">=</span> pm.Normal(<span class="st">'β'</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb57-11"><a href="#cb57-11"></a>    μ <span class="op">=</span> pm.math.exp(α <span class="op">+</span> β <span class="op">*</span> log_pop <span class="op">+</span> f)</span>
<span id="cb57-12"><a href="#cb57-12"></a>    _ <span class="op">=</span> pm.Poisson(<span class="st">'tt_pred'</span>, μ, observed<span class="op">=</span>total_tools)</span>
<span id="cb57-13"><a href="#cb57-13"></a>    idata_islands <span class="op">=</span> pm.sample(target_accept<span class="op">=</span><span class="fl">0.9</span>, random_seed<span class="op">=</span><span class="dv">123</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [η, ℓ, f_rotated_, α, β]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 56 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"4e3e9f7dbb654c10b74ac3b4577dc33c","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<div id="d5d01b64" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a>az.summary(idata_islands, var_names<span class="op">=</span>[<span class="st">'η'</span>, <span class="st">'ℓ'</span>, <span class="st">'α'</span>, <span class="st">'β'</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">mean</th>
<th data-quarto-table-cell-role="th">sd</th>
<th data-quarto-table-cell-role="th">hdi_3%</th>
<th data-quarto-table-cell-role="th">hdi_97%</th>
<th data-quarto-table-cell-role="th">mcse_mean</th>
<th data-quarto-table-cell-role="th">mcse_sd</th>
<th data-quarto-table-cell-role="th">ess_bulk</th>
<th data-quarto-table-cell-role="th">ess_tail</th>
<th data-quarto-table-cell-role="th">r_hat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">η</td>
<td>0.202</td>
<td>0.148</td>
<td>0.020</td>
<td>0.474</td>
<td>0.004</td>
<td>0.003</td>
<td>1424.0</td>
<td>2416.0</td>
<td>1.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">ℓ</td>
<td>2.229</td>
<td>1.416</td>
<td>0.625</td>
<td>4.609</td>
<td>0.028</td>
<td>0.021</td>
<td>4250.0</td>
<td>2309.0</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">α</td>
<td>1.213</td>
<td>1.075</td>
<td>-0.686</td>
<td>3.417</td>
<td>0.032</td>
<td>0.022</td>
<td>1181.0</td>
<td>1512.0</td>
<td>1.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">β</td>
<td>0.254</td>
<td>0.107</td>
<td>0.039</td>
<td>0.442</td>
<td>0.003</td>
<td>0.002</td>
<td>1153.0</td>
<td>1413.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<p>Para entender la distribución posterior de las funciones de covarianza en términos de distancias, podemos representar gráficamente algunas muestras de la distribución posterior como en la siguiente figura. La curva azul más oscura representa la covarianza mediana posterior en cada distancia y las curvas más claras y finas muestran funciones de la distribución posterior conjunta de <span class="math inline">\(\ell\)</span> y <span class="math inline">\(\eta\)</span>.</p>
<p>Usamos la mediana porque las distribuciones para <span class="math inline">\(\ell\)</span> y <span class="math inline">\(\eta\)</span> están muy sesgadas. Podemos ver que la covarianza, en promedio, no es tan alta y también cae a casi 0 a unos 3000 kilómetros. Las líneas delgadas representan la incertidumbre, y podemos ver que hay mucha incertidumbre.</p>
<div id="c2b3176c" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1"></a>posterior_islands <span class="op">=</span> idata_islands.posterior.stack(samples<span class="op">=</span>(<span class="st">"chain"</span>, <span class="st">"draw"</span>))</span>
<span id="cb60-2"><a href="#cb60-2"></a>trace_η <span class="op">=</span> posterior_islands[<span class="st">'η'</span>].values</span>
<span id="cb60-3"><a href="#cb60-3"></a>trace_ℓ <span class="op">=</span> posterior_islands[<span class="st">'ℓ'</span>].values</span>
<span id="cb60-4"><a href="#cb60-4"></a></span>
<span id="cb60-5"><a href="#cb60-5"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">4</span>))</span>
<span id="cb60-6"><a href="#cb60-6"></a><span class="bu">xrange</span> <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">7</span>)</span>
<span id="cb60-7"><a href="#cb60-7"></a></span>
<span id="cb60-8"><a href="#cb60-8"></a>median_ <span class="op">=</span> np.median(trace_η[:,<span class="va">None</span>] <span class="op">*</span> (np.exp(<span class="op">-</span><span class="bu">xrange</span><span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>trace_ℓ[:,<span class="va">None</span>]<span class="op">**</span><span class="dv">2</span>))), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb60-9"><a href="#cb60-9"></a></span>
<span id="cb60-10"><a href="#cb60-10"></a>ax.plot(<span class="bu">xrange</span>, median_, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb60-11"><a href="#cb60-11"></a></span>
<span id="cb60-12"><a href="#cb60-12"></a></span>
<span id="cb60-13"><a href="#cb60-13"></a>ax.plot(<span class="bu">xrange</span>, (trace_η[::<span class="dv">20</span>][:, <span class="va">None</span>] <span class="op">*</span> np.exp(<span class="op">-</span><span class="bu">xrange</span><span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>trace_ℓ[::<span class="dv">20</span>][:, <span class="va">None</span>]<span class="op">**</span><span class="dv">2</span>))).T,</span>
<span id="cb60-14"><a href="#cb60-14"></a>        <span class="st">'C0'</span>, alpha<span class="op">=</span><span class="fl">.1</span>)</span>
<span id="cb60-15"><a href="#cb60-15"></a></span>
<span id="cb60-16"><a href="#cb60-16"></a>ax.set_ylim(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb60-17"><a href="#cb60-17"></a>ax.set_xlabel(<span class="st">'distance (thousand kilometers)'</span>)</span>
<span id="cb60-18"><a href="#cb60-18"></a>ax.set_ylabel(<span class="st">'covariance'</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-45-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Ahora veamos qué tan fuertemente correlacionadas están las sociedades insulares según el modelo y los datos. Para ello, tenemos que convertir la matriz de covarianza en una matriz de correlación.</p>
<div id="fa09516c" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a><span class="co"># Calcular la covarianza mediana posterior entre sociedades</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>Σ <span class="op">=</span> np.median(trace_η) <span class="op">*</span> (np.exp(<span class="op">-</span>(islands_dist)<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>np.median(trace_ℓ)<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb61-3"><a href="#cb61-3"></a></span>
<span id="cb61-4"><a href="#cb61-4"></a></span>
<span id="cb61-5"><a href="#cb61-5"></a><span class="co"># Convertir a matriz de correlación</span></span>
<span id="cb61-6"><a href="#cb61-6"></a>Σ_post <span class="op">=</span> np.diag(np.diag(Σ)<span class="op">**-</span><span class="fl">0.5</span>)</span>
<span id="cb61-7"><a href="#cb61-7"></a>ρ <span class="op">=</span> Σ_post <span class="op">@</span>  Σ <span class="op">@</span> Σ_post</span>
<span id="cb61-8"><a href="#cb61-8"></a>ρ <span class="op">=</span> pd.DataFrame(ρ, index<span class="op">=</span>culture_labels, columns<span class="op">=</span>culture_labels)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La siguiente figura muestra un mapa de calor de la matriz de correlación media.</p>
<p>Dos observaciones destacan del resto: en primer lugar Hawái es una isla muy solitaria. Esto tiene sentido, ya que Hawái está muy lejos del resto de sociedades insulares. Además, podemos ver que Malekula (Ml), Tikopia (Ti) y Santa Cruz (SC) están altamente correlacionadas entre sí. Esto también tiene sentido, ya que estas sociedades están muy próximas entre sí y también tienen una cantidad similar de herramientas.</p>
<div id="bd216ab1" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="fl">4.5</span>, <span class="fl">4.5</span>))</span>
<span id="cb62-2"><a href="#cb62-2"></a>im <span class="op">=</span> ax.imshow(ρ, cmap<span class="op">=</span><span class="st">'viridis_r'</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb62-3"><a href="#cb62-3"></a></span>
<span id="cb62-4"><a href="#cb62-4"></a>ticks_loc <span class="op">=</span> np.arange(<span class="dv">10</span>)</span>
<span id="cb62-5"><a href="#cb62-5"></a>ax.set_xticks(ticks_loc)</span>
<span id="cb62-6"><a href="#cb62-6"></a>ax.set_yticks(ticks_loc)</span>
<span id="cb62-7"><a href="#cb62-7"></a>ax.set_xticklabels(culture_labels, rotation<span class="op">=</span><span class="dv">70</span>)</span>
<span id="cb62-8"><a href="#cb62-8"></a>ax.set_yticklabels(culture_labels)</span>
<span id="cb62-9"><a href="#cb62-9"></a>fig.colorbar(im, ax<span class="op">=</span>ax)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-47-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>El panel izquierdo de la siguiente figura es esencialmente un mapa. Las sociedades insulares están representadas por sus posiciones relativas. Las líneas son las correlaciones medianas posteriores entre sociedades. La opacidad de las líneas es proporcional al valor de las correlaciones. En el panel derecho tenemos nuevamente las correlaciones medianas posteriores, pero esta vez graficadas en términos del logaritmo de la población versus el número total de herramientas. Las líneas discontinuas representan el número mediano de herramientas y el HDI del 94% como función del logaritmo de la población. En ambos paneles de la Figura <span class="math inline">\(\ref{fig:GP_islands_spatial}\)</span>, el tamaño de los puntos es proporcional a la población de cada sociedad insular. Observe cómo las correlaciones entre Malekula, Tikopia y Santa Cruz describen el hecho de que tienen un número bastante bajo de herramientas cercano a la mediana o inferior al número esperado de herramientas para sus poblaciones. Algo similar está sucediendo con Trobriand y Manus; están geográficamente cerca y tienen menos herramientas de lo esperado para el tamaño de sus poblaciones. Tonga tiene muchas más herramientas de lo esperado para su población y una correlación relativamente alta con Fiji. En cierto modo, el modelo nos dice que Tonga tiene un efecto positivo en Lua Fiji, aumentando el número total de herramientas y contrarrestando su efecto sobre sus vecinos cercanos, Malekula, Tikopia y Santa Cruz.</p>
<div id="02cf23b8" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1"></a><span class="co"># scale point size to logpop</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>logpop <span class="op">=</span> np.copy(log_pop)</span>
<span id="cb63-3"><a href="#cb63-3"></a>logpop <span class="op">/=</span> logpop.<span class="bu">max</span>()</span>
<span id="cb63-4"><a href="#cb63-4"></a>psize <span class="op">=</span> np.exp(logpop<span class="op">*</span><span class="fl">5.5</span>)</span>
<span id="cb63-5"><a href="#cb63-5"></a>log_pop_seq <span class="op">=</span> np.linspace(<span class="dv">6</span>, <span class="dv">14</span>, <span class="dv">100</span>)</span>
<span id="cb63-6"><a href="#cb63-6"></a>lambda_post <span class="op">=</span> np.exp(posterior_islands[<span class="st">'α'</span>].values[:, <span class="va">None</span>] <span class="op">+</span></span>
<span id="cb63-7"><a href="#cb63-7"></a>                     posterior_islands[<span class="st">'β'</span>].values[:, <span class="va">None</span>] <span class="op">*</span> log_pop_seq)</span>
<span id="cb63-8"><a href="#cb63-8"></a></span>
<span id="cb63-9"><a href="#cb63-9"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb63-10"><a href="#cb63-10"></a></span>
<span id="cb63-11"><a href="#cb63-11"></a>ax[<span class="dv">0</span>].scatter(islands.lon, islands.lat, psize, zorder<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb63-12"><a href="#cb63-12"></a>ax[<span class="dv">1</span>].scatter(islands.logpop, islands.total_tools, psize, zorder<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb63-13"><a href="#cb63-13"></a></span>
<span id="cb63-14"><a href="#cb63-14"></a><span class="cf">for</span> i, itext <span class="kw">in</span> <span class="bu">enumerate</span>(culture_labels):</span>
<span id="cb63-15"><a href="#cb63-15"></a>    ax[<span class="dv">0</span>].text(islands.lon[i]<span class="op">+</span><span class="dv">1</span>, islands.lat[i]<span class="op">+</span><span class="dv">1</span>, itext)</span>
<span id="cb63-16"><a href="#cb63-16"></a>    ax[<span class="dv">1</span>].text(islands.logpop[i]<span class="op">+</span><span class="fl">.1</span>, islands.total_tools[i]<span class="op">-</span><span class="fl">2.5</span>, itext)</span>
<span id="cb63-17"><a href="#cb63-17"></a></span>
<span id="cb63-18"><a href="#cb63-18"></a></span>
<span id="cb63-19"><a href="#cb63-19"></a>ax[<span class="dv">1</span>].plot(log_pop_seq, np.median(lambda_post, axis<span class="op">=</span><span class="dv">0</span>), <span class="st">'k--'</span>)</span>
<span id="cb63-20"><a href="#cb63-20"></a></span>
<span id="cb63-21"><a href="#cb63-21"></a>az.plot_hdi(log_pop_seq, lambda_post,</span>
<span id="cb63-22"><a href="#cb63-22"></a>            hdi_prob<span class="op">=</span><span class="fl">0.8</span>,</span>
<span id="cb63-23"><a href="#cb63-23"></a>            fill_kwargs<span class="op">=</span>{<span class="st">'alpha'</span>:<span class="dv">0</span>},</span>
<span id="cb63-24"><a href="#cb63-24"></a>            plot_kwargs<span class="op">=</span>{<span class="st">'color'</span>:<span class="st">'k'</span>, <span class="st">'ls'</span>:<span class="st">'--'</span>, <span class="st">'alpha'</span>:<span class="dv">1</span>})</span>
<span id="cb63-25"><a href="#cb63-25"></a></span>
<span id="cb63-26"><a href="#cb63-26"></a></span>
<span id="cb63-27"><a href="#cb63-27"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb63-28"><a href="#cb63-28"></a>    <span class="cf">for</span> j <span class="kw">in</span> np.arange(i<span class="op">+</span><span class="dv">1</span>, <span class="dv">10</span>):</span>
<span id="cb63-29"><a href="#cb63-29"></a>        ax[<span class="dv">0</span>].plot((islands.lon[i], islands.lon[j]),</span>
<span id="cb63-30"><a href="#cb63-30"></a>                   (islands.lat[i], islands.lat[j]), <span class="st">'C1-'</span>,</span>
<span id="cb63-31"><a href="#cb63-31"></a>                   alpha<span class="op">=</span>ρ.iloc[i, j]<span class="op">**</span><span class="dv">2</span>, lw<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb63-32"><a href="#cb63-32"></a>        ax[<span class="dv">1</span>].plot((islands.logpop[i], islands.logpop[j]),</span>
<span id="cb63-33"><a href="#cb63-33"></a>                   (islands.total_tools[i], islands.total_tools[j]), <span class="st">'C1-'</span>,</span>
<span id="cb63-34"><a href="#cb63-34"></a>                   alpha<span class="op">=</span>ρ.iloc[i, j]<span class="op">**</span><span class="dv">2</span>, lw<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb63-35"><a href="#cb63-35"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">'longitud'</span>)</span>
<span id="cb63-36"><a href="#cb63-36"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'latitud'</span>)</span>
<span id="cb63-37"><a href="#cb63-37"></a></span>
<span id="cb63-38"><a href="#cb63-38"></a></span>
<span id="cb63-39"><a href="#cb63-39"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'log-población'</span>)</span>
<span id="cb63-40"><a href="#cb63-40"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">'total herramientas'</span>)</span>
<span id="cb63-41"><a href="#cb63-41"></a>ax[<span class="dv">1</span>].set_xlim(<span class="fl">6.8</span>, <span class="fl">12.8</span>)</span>
<span id="cb63-42"><a href="#cb63-42"></a>ax[<span class="dv">1</span>].set_ylim(<span class="dv">10</span>, <span class="dv">73</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/osvaldo/anaconda3/envs/EI2/lib/python3.11/site-packages/arviz/plots/hdiplot.py:161: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions
  hdi_data = hdi(y, hdi_prob=hdi_prob, circular=circular, multimodal=False, **hdi_kwargs)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-48-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="hsgps" class="level2" data-number="7.11">
<h2 data-number="7.11" class="anchored" data-anchor-id="hsgps"><span class="header-section-number">7.11</span> HSGPs</h2>
<p>Los procesos gaussianos pueden ser lentos. La razón principal es que su cálculo requiere que invirtamos una matriz, cuyo tamaño aumenta con el número de observaciones. En la práctica no se invirte la matriz, si no que se usa una operación más estable numéricamente, llamada descomposición de Cholesky. Pero ambas operaciones escalan con el cubo de los datos, <span class="math inline">\(\mathcal{O}(n^3)\)</span>. Es decir son operaciones costosas que no escalan bien con el número de observaciones. Por esa razón, una gran parte de la investigación en torno a los procesos gaussianos se ha centrado en encontrar aproximaciones para calcularlos más rápido y permitir escalarlos a datasets de gran tamaño.</p>
<p>En este caso vamos a utilizar solo una de esas aproximaciones, llamada Proceso Gaussiano en Espacios de Hilbert (HSGP por su sigla en inglés). Los detalles de esta aproximación exceden la discusión de este curso. Pero conceptualmente podemos decir que un espacio de Hilbert es una generalización del espacio euclídeo que nos brinda el marco matemático para pensar funciones (“vectores infinitos”) y sus distancia, ángulos, etc. En este espacio es posible definir una serie de funciones base que sean ortogonales entre si. Un kernel es aproximado como una serie infinita de estas funciones bases. En la práctica esta serie se trunca. En espíritu estamos haciendo algo similar a como se construyen splines, solo que con otro tipo de función base.</p>
<p>El resultado práctico es que obtenemos un aproximación que escala como <span class="math inline">\(\mathcal{O}(mn + m)\)</span> para <span class="math inline">\(m\)</span> bases. Una limitación es que solo podemos usar HSGP para dimensiones bajas. En general 1 o 2, quizá 3, y solo para algunos kernels como el cuadrático exponencial o Matern, ya que para estos es posible encontrar las funciones base.</p>
<p>Usar la aproximación HSGP en PyMC es sencillo, como demostraremos con el conjunto de datos de bicicletas. Queremos modelar la cantidad de bicicletas alquiladas como una función de la hora del día en horas. El siguiente bloque de código muestra la implementación de PyMC de dicho modelo.</p>
<div id="f456223a" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1"></a>bikes <span class="op">=</span> pd.read_csv(<span class="st">"datos/bikes.csv"</span>)</span>
<span id="cb65-2"><a href="#cb65-2"></a>y <span class="op">=</span> bikes[<span class="st">"rented"</span>].values</span>
<span id="cb65-3"><a href="#cb65-3"></a>X <span class="op">=</span> bikes[<span class="st">"hour"</span>].values[:,<span class="va">None</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="627aa4c5" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> model_hsgp:</span>
<span id="cb66-2"><a href="#cb66-2"></a>    ℓ <span class="op">=</span> pm.InverseGamma(<span class="st">'ℓ'</span>, <span class="op">**</span>get_ig_params(X))</span>
<span id="cb66-3"><a href="#cb66-3"></a></span>
<span id="cb66-4"><a href="#cb66-4"></a>    cov <span class="op">=</span> pm.gp.cov.ExpQuad(<span class="dv">1</span>, ls<span class="op">=</span>ℓ)</span>
<span id="cb66-5"><a href="#cb66-5"></a>    gp <span class="op">=</span> pm.gp.HSGP(m<span class="op">=</span>[<span class="dv">10</span>], c<span class="op">=</span><span class="fl">1.5</span>, cov_func<span class="op">=</span>cov)</span>
<span id="cb66-6"><a href="#cb66-6"></a></span>
<span id="cb66-7"><a href="#cb66-7"></a>    f <span class="op">=</span> gp.prior(<span class="st">'f'</span>, X<span class="op">=</span>X)</span>
<span id="cb66-8"><a href="#cb66-8"></a>    α <span class="op">=</span> pm.HalfNormal(<span class="st">'α'</span>, <span class="dv">1</span>)</span>
<span id="cb66-9"><a href="#cb66-9"></a>    _ <span class="op">=</span> pm.NegativeBinomial(<span class="st">"obs"</span>, np.exp(f), α, observed<span class="op">=</span>y)</span>
<span id="cb66-10"><a href="#cb66-10"></a></span>
<span id="cb66-11"><a href="#cb66-11"></a>    idata_hsgp <span class="op">=</span> pm.sample(random_seed<span class="op">=</span><span class="dv">123</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [ℓ, f_hsgp_coeffs_, α]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 9 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"88f6a6486d24459892971e4a9653d679","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<p>La principal diferencia con los modelos GP anteriores es el uso de la clase <code>pm.gp.HSGP(.)</code>. Para instanciar esta clase necesitamos definir dos parámetros:</p>
<ul>
<li><code>m</code> es el número de funciones base que usamos para aproximar el GP. Cuanto mayor sea el valor de <code>m</code> mejor será la aproximación y más costoso el cálculo.</li>
<li><code>c</code> es un factor de límite. Para un valor fijo y suficientemente grande de <code>m</code>, <code>c</code> afecta la aproximación de la función media principalmente cerca de los límites. No debe ser menor que 1,2 (PyMC le dará una advertencia si usa un valor menor que este), y generalmente 1,5 es una buena opción. Cambiar este parámetro no afecta la velocidad de los cálculos.</li>
</ul>
<p>Establecemos <code>m=10</code> en parte porque somos fanáticos del sistema decimal y en parte basándonos en las recomendaciones del artículo <a href="https://arxiv.org/abs/2004.11408">Practical Hilbert space approximate…</a>. En la práctica, los resultados son robustos a los valores exactos de <code>m</code> y <code>c</code>, siempre que se encuentren dentro de cierto rango que depende del prior de la longitud de escala.</p>
<p>Ahora veamos los resultados.</p>
<div id="06e7ba2a" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1"></a>az.summary(idata_hsgp, var_names<span class="op">=</span>[<span class="st">"ℓ"</span>, <span class="st">"α"</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">mean</th>
<th data-quarto-table-cell-role="th">sd</th>
<th data-quarto-table-cell-role="th">hdi_3%</th>
<th data-quarto-table-cell-role="th">hdi_97%</th>
<th data-quarto-table-cell-role="th">mcse_mean</th>
<th data-quarto-table-cell-role="th">mcse_sd</th>
<th data-quarto-table-cell-role="th">ess_bulk</th>
<th data-quarto-table-cell-role="th">ess_tail</th>
<th data-quarto-table-cell-role="th">r_hat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">ℓ</td>
<td>3.403</td>
<td>0.274</td>
<td>2.910</td>
<td>3.927</td>
<td>0.008</td>
<td>0.005</td>
<td>1265.0</td>
<td>1890.0</td>
<td>1.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">α</td>
<td>1.854</td>
<td>0.140</td>
<td>1.606</td>
<td>2.126</td>
<td>0.002</td>
<td>0.002</td>
<td>3677.0</td>
<td>2934.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div id="f4e1c826" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1"></a>az.plot_trace(idata_hsgp, var_names<span class="op">=</span>[<span class="st">"ℓ"</span>, <span class="st">"α"</span>])<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-52-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>La siguiente figura muestra el GP posterior medio en azul oscuro y 100 muestras (realizaciones) del GP posterior (líneas turquesas). Puedes comparar estos resultados con los obtenidos usando splines.</p>
<div id="499d1646" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1"></a>_, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb70-2"><a href="#cb70-2"></a>ax.plot(bikes[<span class="st">"hour"</span>].values, bikes[<span class="st">"rented"</span>].values, <span class="st">"C2."</span>)</span>
<span id="cb70-3"><a href="#cb70-3"></a></span>
<span id="cb70-4"><a href="#cb70-4"></a></span>
<span id="cb70-5"><a href="#cb70-5"></a>f <span class="op">=</span> az.extract(idata_hsgp, group<span class="op">=</span><span class="st">"posterior"</span>, var_names<span class="op">=</span><span class="st">"f"</span>)</span>
<span id="cb70-6"><a href="#cb70-6"></a>idx <span class="op">=</span> np.argsort(X[:,<span class="dv">0</span>])</span>
<span id="cb70-7"><a href="#cb70-7"></a>ax.plot(bikes[<span class="st">"hour"</span>].values[idx], np.exp(f.values[idx,:<span class="dv">100</span>]), alpha<span class="op">=</span><span class="fl">0.25</span>, color<span class="op">=</span><span class="st">"C1"</span>)</span>
<span id="cb70-8"><a href="#cb70-8"></a></span>
<span id="cb70-9"><a href="#cb70-9"></a>ax.plot(bikes[<span class="st">"hour"</span>].values[idx], np.exp(f.values[idx].mean(<span class="dv">1</span>)), color<span class="op">=</span><span class="st">"C0"</span>, lw<span class="op">=</span><span class="dv">2</span>)<span class="op">;</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-53-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>La aproximación HSGP también está implementada en Bambi. Veamos cómo podemos utilizarla. En principio bastaría hacer</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1"></a>bmb.Model(<span class="st">"rented ~ 0 + hsgp(hour, m=10, c=1.5)"</span>, bikes, family<span class="op">=</span><span class="st">"negativebinomial"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Esto funcionará, pero en general combiene definir priors por nuestra cuenta. Esto dará como resultado un muestreo mucho más rápido y muestras más confiables.</p>
<p>Debemos tener en cuenta que los términos HSGP no reciben valores a priori directamente. En su lugar, necesitamos definir valores a priori para <span class="math inline">\(\ell\)</span> (llamado <code>ell</code> en Bambi) y <span class="math inline">\(\eta\)</span> (llamado <code>sigma</code> en Bambi) y pasar esos valores a priori a los términos HSGP. Una cosa más: en el modelo anterior no usamos <span class="math inline">\(\eta\)</span> pero como Bambi lo espera (ya que es muy común definirlo), usamos un truco bastante barato para definir un valor a priori que sea esencialmente 1.</p>
<div id="57595c2b" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1"></a>prior_gp <span class="op">=</span> {</span>
<span id="cb72-2"><a href="#cb72-2"></a>    <span class="st">"sigma"</span>: bmb.Prior(<span class="st">"Gamma"</span>, mu<span class="op">=</span><span class="dv">1</span>, sigma<span class="op">=</span><span class="fl">0.01</span>),</span>
<span id="cb72-3"><a href="#cb72-3"></a>    <span class="st">"ell"</span>: bmb.Prior(<span class="st">"InverseGamma"</span>, <span class="op">**</span>get_ig_params(X)) </span>
<span id="cb72-4"><a href="#cb72-4"></a>}</span>
<span id="cb72-5"><a href="#cb72-5"></a></span>
<span id="cb72-6"><a href="#cb72-6"></a>priors <span class="op">=</span> {</span>
<span id="cb72-7"><a href="#cb72-7"></a>    <span class="st">"hsgp(hour, m=10, c=1.5)"</span>: prior_gp,</span>
<span id="cb72-8"><a href="#cb72-8"></a>    <span class="st">"alpha"</span>: bmb.Prior(<span class="st">"HalfNormal"</span>, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb72-9"><a href="#cb72-9"></a>}</span>
<span id="cb72-10"><a href="#cb72-10"></a></span>
<span id="cb72-11"><a href="#cb72-11"></a>model_hsb <span class="op">=</span> bmb.Model(<span class="st">"rented ~ 0 + hsgp(hour, m=10, c=1.5)"</span>, bikes, family<span class="op">=</span><span class="st">"negativebinomial"</span>, priors<span class="op">=</span>priors)</span>
<span id="cb72-12"><a href="#cb72-12"></a>idata_hsb <span class="op">=</span> model_hsb.fit(random_seed<span class="op">=</span><span class="dv">123</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [rented_alpha, hsgp(hour, m=10, c=1.5)_sigma, hsgp(hour, m=10, c=1.5)_ell, hsgp(hour, m=10, c=1.5)_weights_raw]
Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 10 seconds.</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"1d57dd0605d149f88a8f848b5aa6d63e","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
<div class="cell-output cell-output-display">
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div>
</div>
<div id="21564cd0" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1"></a>az.summary(idata_hsb, var_names<span class="op">=</span>[<span class="st">"hsgp(hour, m=10, c=1.5)_ell"</span>, <span class="st">"rented_alpha"</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">mean</th>
<th data-quarto-table-cell-role="th">sd</th>
<th data-quarto-table-cell-role="th">hdi_3%</th>
<th data-quarto-table-cell-role="th">hdi_97%</th>
<th data-quarto-table-cell-role="th">mcse_mean</th>
<th data-quarto-table-cell-role="th">mcse_sd</th>
<th data-quarto-table-cell-role="th">ess_bulk</th>
<th data-quarto-table-cell-role="th">ess_tail</th>
<th data-quarto-table-cell-role="th">r_hat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">hsgp(hour, m=10, c=1.5)_ell</td>
<td>3.415</td>
<td>0.270</td>
<td>2.909</td>
<td>3.906</td>
<td>0.008</td>
<td>0.005</td>
<td>1281.0</td>
<td>1938.0</td>
<td>1.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">rented_alpha</td>
<td>1.855</td>
<td>0.137</td>
<td>1.614</td>
<td>2.124</td>
<td>0.002</td>
<td>0.002</td>
<td>3651.0</td>
<td>2997.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div id="87def36d" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1"></a>_, ax <span class="op">=</span> bmb.interpret.plot_predictions(model_hsb, idata_hsb, [<span class="st">"hour"</span>],</span>
<span id="cb75-2"><a href="#cb75-2"></a>                                       fig_kwargs<span class="op">=</span>{<span class="st">"figsize"</span>: (<span class="dv">10</span>, <span class="dv">3</span>)})</span>
<span id="cb75-3"><a href="#cb75-3"></a>ax[<span class="dv">0</span>].plot(bikes[<span class="st">"hour"</span>].values, bikes[<span class="st">"rented"</span>].values, <span class="st">"C2."</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/osvaldo/anaconda3/envs/EI2/lib/python3.11/site-packages/arviz/rcparams.py:368: FutureWarning: stats.hdi_prob is deprecated since 0.18.0, use stats.ci_prob instead
  warnings.warn(</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07_GPs_files/figure-html/cell-56-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="resumen" class="level2" data-number="7.12">
<h2 data-number="7.12" class="anchored" data-anchor-id="resumen"><span class="header-section-number">7.12</span> Resumen</h2>
<p>Un proceso gaussiano es una generalización de la distribución gaussiana multivariada a infinitas dimensiones y está completamente especificado por una función media y una función de covarianza. Dado que podemos pensar conceptualmente en las funciones como vectores infinitamente largos, podemos utilizar procesos gaussianos como valores a priori sobre el espacio de las funciones. En la práctica, no trabajamos con objetos infinitos sino con distribuciones gaussianas multivariadas con tantas dimensiones como observaciones. Para definir la función de covarianza, utilizamos kernels cuyos parámetros debemos ajustar usando datos; al aprender sobre esos hiperparámetros, terminamos aprendiendo sobre funciones complejas arbitrarias.</p>
<p>En este capítulo, hemos dado una breve introducción a los procesos gaussianos. Hemos discutido como hacer regresión, como integrarlos en modelos semiparamétricos (el ejemplo de las islas), como combinar dos o más kernels para describir mejor la función desconocida y cómo se puede utilizar un proceso gaussiano para tareas de clasificación. También discutimos una aproximación, HGSP, que permite reducir el costo computacional de los GPs.</p>
<p>GPs es un tema muy extenso con muchas aplicaciones prácticas, pero que suele estar asociado a explicaciones que requieren un alto grado de sofisticación matemática. Espero que esta introducción más práctica los haya motivado lo suficiente para seguir usando, leyendo y aprendiendo sobre los procesos gaussianos.</p>
</section>
<section id="ejercicios" class="level2" data-number="7.13">
<h2 data-number="7.13" class="anchored" data-anchor-id="ejercicios"><span class="header-section-number">7.13</span> Ejercicios</h2>
<ol type="1">
<li><p>Para el ejemplo de la <span class="quarto-unresolved-ref">?fig-ExpQuad</span>, asegúrese de comprender la relación entre los datos de entrada y la matriz de covarianza generada. Intente utilizar otra entrada como <code>data = np.random.normal(size=4)</code>.</p></li>
<li><p>Vuelva a ejecutar el código que genera la <span class="quarto-unresolved-ref">?fig-ExpQuad_ell</span> y aumente la cantidad de muestras obtenidas del GP anterior a alrededor de 200. En la figura original, la cantidad de muestras es 2. ¿Cuál es el rango de los valores generados?</p></li>
<li><p>Para el gráfico generado en el ejercicio anterior, calcule la desviación estándar para los valores en cada punto. Hazlo de la siguiente forma:</p>
<ul>
<li>Visualmente, simplemente observando los gráficos</li>
<li>Directamente a partir de los valores generados a partir de <code>pz.MVNormal(.).rvs</code></li>
<li>Inspeccionando la matriz de covarianza (si tienes dudas, vuelve al ejercicio 1) ¿Coincidieron los valores que obtuviste de estos tres métodos?</li>
</ul></li>
<li><p>Usa los puntos de prueba <code>np.linspace(np.floor(x.min()), 20, 100)[:,None]</code> y vuelve a ejecutar <code>model_reg</code>. Grafica los resultados. ¿Qué observaste? ¿Cómo se relaciona esto con la especificación de la prior GP?</p></li>
<li><p>Repite el ejercicio 1, pero esta vez usa un kernel lineal.</p></li>
<li><p>Consulta <a href="https://www.pymc.io/projects/examples/en/latest/gaussian_processes/GP-MeansAndCovs.html">Funciones de Media y Covarianza</a> en la documentación de PyMC.</p></li>
<li><p>Ejecuta un modelo de regresión logística para los datos de <code>space_flu</code>. ¿Qué ves? ¿Puedes explicar el resultado?</p></li>
<li><p>Cambia el modelo de regresión logística para que se ajuste a los datos. Consejo: usa un polinomio de orden 2.</p></li>
<li><p>Compara el modelo para el desastre de la minería de carbón con el de la <a href="https://www.pymc.io/projects/docs/en/stable/learn/core_notebooks/pymc_overview.html#case-study-2-coal-mining-disasters">documentación de PyMC</a>. Describe las diferencias entre ambos modelos en términos de especificación del modelo y resultados.</p></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./06_modelos_de_mezcla.html" class="pagination-link" aria-label="Modelos de mezcla">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Modelos de mezcla</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./08_BART.html" class="pagination-link" aria-label="Árboles de regresión aditivos Bayesianos">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Árboles de regresión aditivos Bayesianos</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png"></a><br>Este obra está bajo <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">licencia Creative Commons Reconocimiento 4.0 Internacional</a>.</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>